%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Python i LinAlys og MekRel}
\date{Jul 26, 2021}
\release{}
\author{Niels Bohr Institutet}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}




\sphinxstyleemphasis{\sphinxstylestrong{Jonathan Melcher, Johann Bock Severin, Linea Stausbøll Hedemark, Børge Svane Nielsen \& Sune Olander}}

I fysik benytter vi Python som kodesprog. Denne side kommer til at indeholde alt Python, som bliver brugt i kurserne MekRel og LinAlys i blok 1 og 2. Siden er bygget op, så der er en fælles installationsguide og en lille guide til, hvordan man kommer i gang med at kode Python. Derefter vil brugen af Python dog være meget forskellig fra LinAlys og MekRel og der er derfor to sektioner, hvor hvert kursus har noter liggende.

I MekRel\sphinxhyphen{}sektionen vil man finde noter, der introducerer, hvordan man foretager numeriske udregninger, fitter funktioner og plotter, så man kan lave databehandling i laboratoriet. Dette gøres primært ved brug af pakkerne NumPy, SciPy og Matplotlib.

I LinAlys\sphinxhyphen{}sektionen er fokus på at benytte Python som CAS\sphinxhyphen{}værktøj til at foretage og tjekke symbolske udregninger. Dette gøres med pakken SymPy, som bliver gennemgået.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Hvad er Python?}
\end{DUlineblock}

Når vi programmerer en computer, vælger vi et programmeringssprog. Dette sprog afgør, hvordan vores instruktioner bliver oversat til maskinkode, som så kan køre på vores computer.

Der findes mange forskellige programmeringssprog med hver deres fordele og ulemper. Python er bygget op til at ligge så tæt som muligt på det engelske sprog.  Dette betyder ofte, at Python ikke er ligeså hurtigt at køre, men forhåbentlig lidt mere \sphinxstyleemphasis{intuitivt} end mange andre sprog. Desuden har Python den fordel, at det er i meget hurtig vækst, så man kan næsten finde implementeringer af alle tænkelige algoritmer i sproget.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Hvad skal vi bruge det til?}
\end{DUlineblock}

På fysik benyttes Python til mange forskellige opgaver, og det er derfor en rigtig god investering af tid at lære. Allerede i løbet af det første halve år, vil I se det blive brugt til databehandling i laboratoriet og til symbolske udregninger i LinAlys. Senere vil man også se det simuleringer, numeriske udregninger og måske bare til at automatisere udregninger, som man foretager ofte.

I blok 1 og 2 forventer vi dog ikke, at I for alvor lærer programmering, det skal nok komme senere. Det er snarere meningen, at man skal stifte bekendtskab med Python som værktøj. Med de forskellige noter på den her side er det forhåbentligt muligt at stykke små koder sammen, som kan løse de problemer, som I støder på.


\chapter{Installation af Python}
\label{\detokenize{notebooks/Download_guide_anaconda/Download_anaconda_jupyter:installation-af-python}}\label{\detokenize{notebooks/Download_guide_anaconda/Download_anaconda_jupyter::doc}}
Før vi kan gå i gang med at bruge Python, må vi først få installeret. På fysik har vi besluttet at installere Anaconda implementationen, da denne kommer med stort set alle de pakker, som man skal bruge, når man starter op. Vi kan derfor kun nøjes med at foretage en installation.


\section{Download Anaconda}
\label{\detokenize{notebooks/Download_guide_anaconda/Download_anaconda_jupyter:download-anaconda}}
Gå først ind på \sphinxurl{https://www.anaconda.com/products/individual}. Det bør gerne se således ud;
\sphinxincludegraphics{{2021-07-10-17-14-27}.png}

Scroll ned til bunden og tryk på den installation, der passer til dit system.
\sphinxincludegraphics{{2021-07-10-17-17-49}.png}

Gem installeren og kør den.


\section{Installation}
\label{\detokenize{notebooks/Download_guide_anaconda/Download_anaconda_jupyter:installation}}
Tryk \sphinxstyleemphasis{Next} > \sphinxstyleemphasis{I agree} > \sphinxstyleemphasis{Next}, vælg det sted du vil installere Anaconda (evt. bare den foreslået lokation), > Tryk ja i de to ticks, hvis du aldrig har arbejdet med Python før. \sphinxstyleemphasis{Install} > \sphinxstyleemphasis{Next} > \sphinxstyleemphasis{Next} > Fjern de to ticks og tryk finish.


\section{Åbne Jupyter Notebook}
\label{\detokenize{notebooks/Download_guide_anaconda/Download_anaconda_jupyter:abne-jupyter-notebook}}
Åben Anaconda Navigator, og kør den (vær ikke bange hvis der kommer en terminal op, det gør der også hos mig). Tryk på \sphinxstyleemphasis{launch} under Jupyter Notebook, markeret med rød under
\sphinxincludegraphics{{2021-07-10-17-34-55}.png}

\sphinxstylestrong{OBS​:} Her kan du se den mappe, som min åbner. Jeg vil ikke gemme min kode her, og det vil du nok heller ikke. For at holde styr på sit arbejde, kan man med fordel gemme sin kode i forskellige mapper. Derfor skal man navigere derhen, hvor man gerne vil gemme sin kode. Det kunne være en mappe, der hedder \sphinxcode{\sphinxupquote{MekRel\_Python\_aflevering\_1}}.

\sphinxincludegraphics{{2021-07-10-17-36-23}.png}

Tryk så på \sphinxstyleemphasis{New} (oppe til højre) > Python 3.

Du har nu åbnet en Python notebook og kan nu skrive Python. Selv Notebooken har følgene layout:

\sphinxincludegraphics{{Jupyter_layout}.png}

De vigtigste knapper at kende på værktøjsbjælken kan findes her:

\sphinxincludegraphics{{Jupyter_layout_toolbar}.png}

Nu er du klar til at programmere i Python.


\chapter{Kom i gang med Python}
\label{\detokenize{notebooks/Basal_python:kom-i-gang-med-python}}\label{\detokenize{notebooks/Basal_python::doc}}
På fysik stifter i bekendtskab med Python både i MekRel og i LinAlys. Der er mange forskellige måder at skrive Python på, men vi vil foreslå, at I benytter Jupyter Notebooks, som kan findes i en installation af Anaconda.

I Notebooks skriver man sin kode i celler. Der bliver primært brugt to slags celler: “Code” eller “Markdown”. Denne celle er en Markdown celle og indholdet formateres som tekst, når cellen køres. Kodeceller er de celler vi skriver vores kode i. Markdown celler kan bruges til at skrive noter i. Dette kunne være ens overvejelser i forbindelse med et forsøg i laboratoriet.

\sphinxstylestrong{Tip:} Man kan med fordel bruge tastaturgenvejen \sphinxcode{\sphinxupquote{shift}} + \sphinxcode{\sphinxupquote{enter}} for at køre en celle, og bevæge sig videre til den næste celle i rækken.


\section{Hvordan virker Python?}
\label{\detokenize{notebooks/Basal_python:hvordan-virker-python}}
Når  vi skriver kode i en celle og kører det, så bliver det læst linje for linje. Et computerprogram bliver altså en liste af computer\sphinxhyphen{}operationer, som skal foretages i en bestemt rækkefølge. Hvis man vil markere noget, som comptueren ikke skal køre, kan det markeres med \#. Dette bruges ofte til kommentar til den, der læser koden.

Når man arbejder i Python, gemmes svaret på en operation ikke nødvendigvis. Vi benytter derfor  =  til at definere en variabel. Dette kunne eksempelvis være  a = 5 . Da vil vi kunne indsætte a i et udtryk, og a vil nu blive betragtet som 5.

En god måde at se en værdi på, er ved at bede Python om at printe den. Dette gøres ved at skrive print(X), hvor X kan være et hvilket som helst variabelnavn.

Eksempelvis kan vi definere variablen hello og printe den.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hello} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello World}\PYG{l+s+s2}{\PYGZdq{}} \PYG{c+c1}{\PYGZsh{} Anførselstegnene (eller \PYGZdq{}gåseøjnene\PYGZdq{}) indikerer at variablen tildeles et tekstudtryk, en såkaldt \PYGZdq{}string\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{hello}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello World
\end{sphinxVerbatim}

I en notebook er det faktisk ikke nødvendigt at printe den \sphinxstyleemphasis{sidste} linje, man kan blot skrive variabelnavnet, og så vil Jupyter selv printe det:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hello}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Hello World\PYGZsq{}
\end{sphinxVerbatim}


\subsection{Variabeltyper}
\label{\detokenize{notebooks/Basal_python:variabeltyper}}
Udover tekststrenge, som vi så i ovenstående eksempel, findes flere forskellige typer variable, som man kan benytte sig af. I Python er det dog ikke nødvendigt at angive disse, da computeren selv finder ud af det fra kontekst.

De mest almindelige variabeltyper er:
\begin{itemize}
\item {} 
Integers (heltal): her skriver vi blot et helt tal, som eksempelvis a = 6

\item {} 
Float (decimaltal): indgår der et decimalpunktum, ‘.’, får vi automatisk en float\sphinxhyphen{}variabel, som eksempelvis kroner\_per\_euro = 7.46.

\item {} 
String (tekststreng): Når vi vil have en variabel til at indeholde tekst, markeres det med anførselstegn/gåseøjne, f.eks. som ovenfor hello = “Hello World”

\item {} 
Boolean (sandt/falsk): Hvis vi skal angive en værdi som enten sandt eller falsk, bruger vi en “boolean variable” og kan skrive switch = True. Falsk skal gives ved False, og bemærk igen at der er forskel på Svar = True og Svar = “True”, idet Svar i sidstnævnte tilfælde istedet bliver en string, som indeholder ordet True, og ikke et logisk udtryk.

\end{itemize}


\subsection{Lister af variable}
\label{\detokenize{notebooks/Basal_python:lister-af-variable}}
Vi kan sammensætte lister af flere værdier, eksempelvis en samling af tal. Dette gøres mest almindeligt ved at lave en liste.:
tal = {[}4, 7, 10{]}. Nu vil tal altså indeholde værdierne 4, 7 og 10. Hvis vi ønsker et enkelt element fra vores liste, kan vi hente dem ved at skrive tal{[}index{]}, hvor værdien af index angiver placeringen i listen vi ønsker at få ud.

\sphinxstylestrong{Tip:} Python starter ved nul (nul\sphinxhyphen{}indeksering), så det første element er altså tal{[}0{]}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tal} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{n}{tal}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
\end{sphinxVerbatim}

Vi ser altså, at når vi kalder tal{[}1{]} får vi det andet element ud, som i definitionen var givet ved 7. Dette er et resultat af nul\sphinxhyphen{}indeksering. Man kan ofte få en fejl her, når man ikke er vant til Python, så tjek det, hvis koden ikke virker eller giver uventede resultater.

Elementer kan tilføjes til listen ved at benytte koden .append(element) efter vores liste. Dette tilføjer elementet til den pågældende variabel i slutningen af listen. Eksempelvis, hvis vi ønsker at udvide vores tal\sphinxhyphen{}liste, kan vi skrive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tal}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{tal}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[4, 7, 10, 6]
\end{sphinxVerbatim}

og vi har nu tilføjet 6 til vores liste.


\section{Basale regneoperationer}
\label{\detokenize{notebooks/Basal_python:basale-regneoperationer}}
Python indeholder som udgangspunkt de mest basale regneoperationer, som man kender fra sin lommeregner. Eksempelvis kan vi lægge til, trække fra, gange og dividere ved blot at skrive udtrykket op med ‘+’, ‘\sphinxhyphen{}‘, ‘*’ og ‘/’. På sædvanligvis  kan vi også benytte parenteser til at give rækkefølgen for operationerne. Nogle enkelte eksempler er givet nedenunder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi adderer blot to tal}
\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Angiver vi ikke parenteser, følger Python selv regne\PYGZhy{}hierakiet}
\PYG{l+m+mi}{9} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Men vi kan selvfølgelig ændre dette med parenteser}
\PYG{p}{(}\PYG{l+m+mi}{9} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
12
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Og vi skal selvfølgelig ikke dividere med 0, hvis ikke vi ønsker en fejl}
\PYG{l+m+mi}{100} \PYG{o}{/} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ZeroDivisionError}\PYG{g+gWhitespace}{                         }Traceback (most recent call last)
\PYG{o}{\PYGZlt{}}\PYG{n}{ipython}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{input}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5e10904}\PYG{n}{e16be}\PYG{o}{\PYGZgt{}} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} Og vi skal selvfølgelig ikke dividere med 0, hvis ikke vi ønsker en fejl}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{l+m+mi}{100} \PYG{o}{/} \PYG{l+m+mi}{0}

\PYG{n+ne}{ZeroDivisionError}: division by zero
\end{sphinxVerbatim}

Udover disse operationer, kan vi også opløfte i en potens ved at benytte **.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{17} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Kvadratet på 17}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{81} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Eller benytte at kvadratroden af x er x**(1/2) til at finde kvadratroden af 81}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
289
9.0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{81} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Bemærk at dette IKKE beregner kvadratroden af 81 ligesom ovenfor:forskellen er parentesen}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
40.5
\end{sphinxVerbatim}

Ønsker man at benytte funktioner som logaritmer, trigonometriske funktioner eller lign., bliver man ofte nødt til at importere et modul, som kan gøre det. Men det vil vi komme ind på senere i noterne om SymPy og NumPy.


\subsection{Ændring af variable}
\label{\detokenize{notebooks/Basal_python:aendring-af-variable}}
Der kan være mange årsager til, at man skal ændre værdien på en varibel. Det kunne f. eks. være i en simulation, hvor positionen af et objekt skal opdateres efter et lille tidsskridt. Benytter vi samme variabelnavn i en ny definition ændrer vi blot værdien:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vari} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{vari}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Her er variablen lig med 15}
\PYG{n}{vari} \PYG{o}{=} \PYG{l+m+mi}{20} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{vari}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Nu er den sat til 20}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
20
\end{sphinxVerbatim}

Når vi benytter et lighedstegn, så udregnes først værdien på højre side, inden værdien bliver gemt med variabelnavnet til venstre. Vi kan altså godt benytte en variabel til at redefinere sig selv. Her benytter vi \sphinxcode{\sphinxupquote{vari}} til at gøre \sphinxcode{\sphinxupquote{vari}} 10 gange større.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vari} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{vari}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} Sat til 7}
\PYG{n}{vari} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{vari} \PYG{c+c1}{\PYGZsh{} `vari` bruges til at udregne en ny værdi for sig selv}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{vari}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
70
\end{sphinxVerbatim}

Der er dog også nogle indbyggede smutveje til at ændre variables værdier i faste trin. Hvis man gerne vil lade en variabel vokse i skridt af increment = 2.5, kan man benytte smutvejs\sphinxhyphen{}notationen += til at ændre variablen i skridt af increment

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{increment} \PYG{o}{=} \PYG{l+m+mf}{2.5}
\PYG{n}{value} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}

\PYG{n}{value} \PYG{o}{+}\PYG{o}{=} \PYG{n}{increment} \PYG{c+c1}{\PYGZsh{} Vi øger value med værdien af vores increment}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
5
7.5
\end{sphinxVerbatim}

Dette virker også for de andre basale operationer ved at skrive \sphinxhyphen{}=, *=, og man kan eksempelvis benytte /= 2, til at redefinere et tal til at være halvt så stort.


\section{Kontrolstrukturer og Løkker}
\label{\detokenize{notebooks/Andet_python:kontrolstrukturer-og-lokker}}\label{\detokenize{notebooks/Andet_python::doc}}
\sphinxstyleemphasis{Denne side bygger ovenpå den tidligere, og omhandler hvordan man kan bygge kode op med brugen af kontrolstrukturer og løkker til eksempelvis at gentage kode. I MekRel og LinAlys benytter vi dog primært moduler, som tager sig af den logik og de løkker, som man skal bruge. Derfor er det ikke strengt nødvendigt at læse den her side, selvom det er nogle meget brugbare emner, der helt sikkert vil være med til at forbedre forståelsen for Python.}


\subsection{Logik i Python}
\label{\detokenize{notebooks/Andet_python:logik-i-python}}
Når vi skriver kode, er vi ret ofte interesseret i, om et udtryk er sandt eller falsk for vide, hvordan vi skal eksekvere resten af koden. Til dette benytter vi boolean variable, som enten kan være \sphinxcode{\sphinxupquote{True}} eller \sphinxcode{\sphinxupquote{False}}. Enten kan vi selv definere en variabel som værende sand ved at skrive \sphinxcode{\sphinxupquote{switch = True}}, men oftere skal vi dog tjekke om noget er sandt.

Når man benytter to lighedstegn \sphinxcode{\sphinxupquote{==}} tjekker Python om udtrykkene på hver side er lig hinanden. Eksempelvis kan vi se om vores defineret værdi er lig med 10:

\sphinxstyleemphasis{Bemærk denne forskel et lighedstegn definerer og to sammenligner:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} Definer variabel}
\PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} Sammenlign variabel med værdi}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{c+c1}{\PYGZsh{} Vi øger værdien med 2}
\PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} Og sammenligner igen}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

I det andet tilfælde har vi redefineret \sphinxcode{\sphinxupquote{i}} til \sphinxcode{\sphinxupquote{i = 12}} og udtrykket er altså ikke længere sandt.

Udover at benytte == kan vi benytte forskellige andre tegn til at danne udsagn, der kan være sande eller falske:
\begin{itemize}
\item {} 
< eller > fortæller om en værdi er større eller mindre end en anden

\item {} 
<= eller >= er ligesom overstående men inkluderer også lig med

\item {} 
!= givet modsat tegn af ==. Altså spørger om noget \sphinxstyleemphasis{er forskelligt fra}

\item {} 
not ændrer sandhedsværdien af et udtryk til det omvendte, eksempelvis er værdien af not True netop False og dermed er not 1 == 2 sandt idet 1 og 2 jo ikke er ens.

\item {} 
in kan bruges til at spørge om et element er i en liste. Eksempelvis vil 7 in tal give \sphinxcode{\sphinxupquote{True}}, hvis \sphinxcode{\sphinxupquote{tal}} er en liste, som indeholder 7, som det gjorde på tidligere side.

\end{itemize}


\subsection{If\sphinxhyphen{}else\sphinxhyphen{}statements}
\label{\detokenize{notebooks/Andet_python:if-else-statements}}
Særligt gør boolean logik sig nyttig, når vi skal eksekvere noget kode, hvis et bestemt udtryk er sandt og noget andet, hvis det ikke er. Her kan vi benytte if/else statements. Her ser syntaksen sådan her ud:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{Statement}\PYG{p}{:}
    \PYG{o}{\PYGZti{}} \PYG{n}{gør} \PYG{n}{det} \PYG{n}{her} \PYG{o}{\PYGZti{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{o}{\PYGZti{}} \PYG{n}{gør} \PYG{n}{noget} \PYG{n}{andet} \PYG{o}{\PYGZti{}}
\end{sphinxVerbatim}

Hvad der sker, afhænger af sandhedsværdien af udtrykket \sphinxcode{\sphinxupquote{Statement}}. Hvis det logiske udsagn \sphinxcode{\sphinxupquote{Statement}} er sandt, udføres første del af koden, ellers udføres den anden del. Man kan udelade else, og i dette tilfælde vil der kun ske noget såfremt \sphinxcode{\sphinxupquote{Statement}} er sandt.
Bemærk at indrykningen spiller en vigtig rolle i at afgrænse, hvad der skal gøres i de enkelte tilfælde.

Her er et eksempel, hvor vi vil tage absolutværdien af et tal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}
\PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hvis a er negativt, så gør følgende:}
    \PYG{c+c1}{\PYGZsh{} Vi printer, hvis vi går ind i denne del af koden.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bingo: Vi startede med et negativt tal, så if\PYGZhy{}betingelsen var opfyldt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 
    \PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{a}   \PYG{c+c1}{\PYGZsh{} Sæt a lig med sig selv med omvendt fortegn}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Bingo: Vi startede med et negativt tal, så if\PYGZhy{}betingelsen var opfyldt
100
\end{sphinxVerbatim}

Hvis vi gentager testen nu hvor a er blevet positiv, vil betingelsen i if\sphinxhyphen{}sætningen ikke være opfyldt, og der sker ikke noget i if\sphinxhyphen{}sætningen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hvis a er negativt, så gør følgende:}
     \PYG{c+c1}{\PYGZsh{} Vi printer, hvis vi går ind i denne del af koden.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bingo: Vi startede med et negativt tal, så if\PYGZhy{}betingelsen var opfyldt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{a} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{a}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
100
\end{sphinxVerbatim}

Bemærk at print(a) ikke er indrykket og dermed ikke er en del af if\sphinxhyphen{}sætningen. Værdien af a udskrives derfor uanset fortegn.

Et andet eksempel kunne være, hvis vi ønsker at dividere et tal med et andet, men have den tomme variabel None, hvis vi bliver bedt om at dividere med 0 (og dermed undgår en fejlmeddelelse). Til dette kan vi benytte vores if\sphinxhyphen{}else:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tæller} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{nævner} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{k}{if} \PYG{n}{nævner} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hvis nævneren er forskellige fra nul, kan brøken beregnes}
    \PYG{n}{resultat} \PYG{o}{=} \PYG{n}{tæller} \PYG{o}{/} \PYG{n}{nævner}
\PYG{k}{else}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Ellers kan vi ikke beregne resultatet}
    \PYG{n}{resultat} \PYG{o}{=} \PYG{k+kc}{None}   \PYG{c+c1}{\PYGZsh{} None er et tomt element. Denne har ingen værdi}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{resultat}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
None
\end{sphinxVerbatim}

Hvis der er brug for flere rangordnede betingelser for at afgøre hvilken handling, koden skal udføre, kan man benytte elif second\_statement (elif er kort for else\sphinxhyphen{}if). Så opbygger man syntaksen som

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{Statement}\PYG{p}{:}
    \PYG{o}{\PYGZti{}} \PYG{n}{gør} \PYG{n}{det} \PYG{n}{her} \PYG{o}{\PYGZti{}}
\PYG{k}{elif} \PYG{n}{Second\PYGZus{}statement}\PYG{p}{:}
    \PYG{o}{\PYGZti{}} \PYG{n}{gør} \PYG{n}{en} \PYG{n}{andet} \PYG{n}{ting} \PYG{o}{\PYGZti{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{o}{\PYGZti{}} \PYG{n}{ellers} \PYG{n}{gør} \PYG{n}{det} \PYG{n}{her} \PYG{o}{\PYGZti{}}
\end{sphinxVerbatim}

Hvis man vil tjekke flere ting, kan man blot tilføje flere elif statements under hinanden.I dette tilfælde vil koden altid køre præcis én kodebid: Koden checker først \sphinxcode{\sphinxupquote{Statement}} og hvis denne er sand vil den \sphinxstylestrong{kun} køre den tilhørende del af koden uanset om \sphinxcode{\sphinxupquote{Second\_statement}} også er sand. Hvis \sphinxcode{\sphinxupquote{Statement}} er falskt, vil den tjekke elif\sphinxhyphen{}statementerne i rækkefølge og eksekverer, den første som er sand. Hvis ingen af de givne betingelser er opfyldt, vil den køre koden der følger efter else.


\subsection{Løkker/loops}
\label{\detokenize{notebooks/Andet_python:lokker-loops}}
Ofte bruger vi computeren til at gentage opgaver mange gange. Dette gør vi ved brug af løkker (ofte kaldt loops). Der er to typer: en for\sphinxhyphen{}løkke og en while\sphinxhyphen{}løkke. I denne Notebook vil vi dog kun vise for\sphinxhyphen{}løkker, som bruges ved at sætte følgende struktur op:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{variabel} \PYG{o+ow}{in} \PYG{n}{liste}\PYG{p}{:}
    \PYG{o}{\PYGZti{}} \PYG{n}{gør} \PYG{n}{det} \PYG{n}{her} \PYG{o}{\PYGZti{}}
\end{sphinxVerbatim}

Løkken tildeler \sphinxcode{\sphinxupquote{variabel}} værdier fra listen. Kodebiden, som er indrykket køres nu en gang for hvert element i listen, hvor \sphinxcode{\sphinxupquote{variabel}} hver gang refererer til det næste element i listen. Det er normal praksis at kalde den variabel i løkke\sphinxhyphen{}definitionen for i hvis der ikke er nogen særlig grund til at bruge et andet navn. Hvis vi eksempelvis vil beregne og udskrive kvadratet på 2, 3, 5 og 7, kan vi skrive det som:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tal} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{tal}\PYG{p}{:}     \PYG{c+c1}{\PYGZsh{} Variablen hedder \PYGZsq{}i\PYGZsq{} og vil antage værdierne i listen \PYGZsq{}tal\PYGZsq{}.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Print kvadratet på tallet `i`}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
9
25
49
\end{sphinxVerbatim}

Hvis vi er interreseret i at gøre noget et bestemt antal gange, kan vi benytte range(antal) til at generere en liste med tallene fra 0 og op til antal \sphinxhyphen{} 1 (på grund af nulindekseringen så er der stadig \sphinxcode{\sphinxupquote{antal}} tal i listen). Lad os prøve at gange et tal med 10, printe det og så gentage dette 5 gange:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Vi har denne gang ikke tænkt os at benytte \PYGZsq{}i\PYGZsq{} til noget, men det skal stadig være der}
    \PYG{n}{a} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{c+c1}{\PYGZsh{} redefiner a ved at gange det med 10}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
30
300
3000
30000
300000
\end{sphinxVerbatim}

Vi kan også give range() flere argumenter. Kaldesekvensen er range(start, stop, skridtstørrelse) hvor alle tallene er heltal. Det er vigtigt at notere sig, at værdien ‘stop’ ikke kommer med i listen, så hvis vi ønsker at finde summen af alle tal i 5\sphinxhyphen{}tabellen fra 0 til 40, kan vi skrive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{summen} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} For at nå op til 40 skal \PYGZsq{}range\PYGZsq{} have et helt tal mellem 41 og 45 som værdien for \PYGZsq{}stop\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Vi lægger }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ til }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{summen}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{summen} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Og summen er }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{summen}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Vi lægger 0 til 0
Vi lægger 5 til 0
Vi lægger 10 til 5
Vi lægger 15 til 15
Vi lægger 20 til 30
Vi lægger 25 til 50
Vi lægger 30 til 75
Vi lægger 35 til 105
Vi lægger 40 til 140
Og summen er 180
\end{sphinxVerbatim}

Vi havde fået samme resultat, hvis vi i stedet for 45 havde skrevet 41, da range forsætter indtil i’et er større eller lig med vores stop.


\chapter{Intro til pakker}
\label{\detokenize{notebooks/Intro_til_pakker:intro-til-pakker}}\label{\detokenize{notebooks/Intro_til_pakker::doc}}
Python er et af de mest brugte programmeringsprog i verden, specielt i den akademiske verden. Derfor er der også en kæmpe mængde pakker, som kan løse alverdens problemer. Her i starten skal I stifte bekendskab med 4:
\begin{itemize}
\item {} 
Sympy (\sphinxhref{https://www.sympy.org/en/index.html}{dokumentation})

\item {} 
Numpy (\sphinxhref{https://numpy.org/doc/stable/}{dokumentation})

\item {} 
Matplotlib (\sphinxhref{https://matplotlib.org/stable/index.html}{dokumentation})

\item {} 
Scipy (\sphinxhref{https://docs.scipy.org/doc/scipy/reference/}{dokumentation})

\end{itemize}

Det ligger næsten i navnet hvad de kan, og hvad de skal bruges til:
\begin{itemize}
\item {} 
Sympy (Symbolic Python) er til symbolsk matematik

\item {} 
Numpy (Numerical Python) er til numeriske beregninger

\item {} 
Matplotlib (Mathematical ploting library) er til at lave plots

\item {} 
Scipy (Scientific Python) her skal vi kun bruge en funktion

\end{itemize}

Ligesom det er vigtigt at bruge den rigtige metode til at løse en ligning, er det ligeså vigtigt at bruge den rigtige pakke til et programmeringsproblem. Som tommelfingerregel skal I bruge Sympy i LinAlys til at foretage symbolske udreginger for at kontrollere svar og lave nogle simple plots af funktioner. I laboratoriet skal I bruge Numpy og Matplotlib til at behandle og illustrere jeres data fra og Scipy til at lave fits.

Nogle af pakkerne har noget overlap, og de er lavet til at kunne bruges sammen. Til at starte med, vil vi dog prøve at undgå dette, da det hurtig kan blive meget kompliceret og nok en kilde til fejl.


\section{Import}
\label{\detokenize{notebooks/Intro_til_pakker:import}}
For at hente en af de 4 ovenstående pakker ind i et python script benytter vi os af \sphinxcode{\sphinxupquote{import}} nøgleordet, som fortæller python, at funktionerne skal hentes fra den pågældende pakke. Med \sphinxcode{\sphinxupquote{as}} kan vi desuden give dem et navn, så man slipper for at skrive hele navnet hver gang man bruger pakken. Vi kan hente de fire pakker ved at skrive følgende i en celle: (i \sphinxcode{\sphinxupquote{scipy.optimize}} specificerer vi her, at vi kun vil hente én funktion derfra, \sphinxcode{\sphinxupquote{curve\_fit}})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{curve\PYGZus{}fit}
\end{sphinxVerbatim}

Selvom det er fristende altid at hente alle pakkerne ind, så er det en fordel kun at hente de pakker ind, som man skal bruge. Dette vil både gøre koden hurtigere, hvis ikke den skal til at hente et stort bibliotek af funktioner, for at man bruger en enkel funktion. Det er også en fordel, hvis andre personer skal læse koden, at man tydeligt kan se, hvilke pakker og funktioner, som skal bruges for at køre ens kode.

Nogle pakker bruger vi så ofte, at vi gerne forkorter deres navne, så vi slipper for at skrive det fulde navn mange gange i løbet af en enkel notebook. Det er her vi bruger \sphinxcode{\sphinxupquote{as}} nøgleordet. Når I gør dette, så brug dog gerne den konventionelle forkortelse (altså den som vi har brugt i cellen overfor), så vil det nemlig være nemmere for jer selv, jeres medstuderende og jeres instruktorer at læse og forstå den kode, som I skriver.


\section{Hvordan bruger man en pakke?}
\label{\detokenize{notebooks/Intro_til_pakker:hvordan-bruger-man-en-pakke}}
Når man har hentet sin pakke ind, kan man kalde de funktioner, som er i den. Hvis man har gjort som \sphinxcode{\sphinxupquote{curve\_fit}} ovenover, kan man blot skrive \sphinxcode{\sphinxupquote{curve\_fit(\_input\_)}} i sin kode. Hvis man til gengæld har hentet en hel pakke, skal man også specificere pakken for at benytte en funktion. Man ville generelt skrive det op som: \sphinxcode{\sphinxupquote{{[}forkortelse for pakke{]}.{[}funktion{]}({[}variable{]}}} f. eks. \sphinxcode{\sphinxupquote{np.exp(2)}} giver \(e^2\).

Tænk på det som et bibliotek af funktioner. Numpy er biblioteket og exp er en bog i biblioteket. For at Python kan finde en funktion, skal du altså først fortælle, hvilket bibliotek Python skal gå til og derefter hvilken bog/funktion skal findes. Nogle biblioteker har også sektioner. Fx bruger vi udelukkende pyplot afdelingen af matplotlib biblioteket.

Herunder kan man se nogle få eksempler på funktionkald:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Både sympy og numpy har de kendte matematiske funktioner, husk ikke at blande dem.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1
\PYGZhy{}1.0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Intro_til_pakker_7_0}.png}

Flere eksempler kan ses  herunder, hvor de mest brugte pakker: numpy, matplotlib og sympy er kort gennemgået. Dette er dog kun en oversigt, for at se en mere grundig gennemgang skal man finde noterne under enten “Python i Mekrel” eller “Python i LinAlys”.


\section{Numpy}
\label{\detokenize{notebooks/Intro_til_pakker:numpy}}
Numpy er den pakke, som vi bruger til numeriske udregninger. Helt centralt er numpy arrays, som er lister, der tillader matematiske operationer på alle elementer samtidig. Vi starter med at importere numpy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

Og vi kan nu tage en liste af nogle tal og konvertere til et numpy array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array\PYGZus{}af\PYGZus{}tal} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{array\PYGZus{}af\PYGZus{}tal}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([ 1,  4,  9, 16, 25])
\end{sphinxVerbatim}

Hvis vi nu benytter dette array i regneoperation, foretages operationer på alle elementer af gangen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array\PYGZus{}af\PYGZus{}tal} \PYG{o}{+} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([ 6,  9, 14, 21, 30])
\end{sphinxVerbatim}

Derudover har numpy også en del indbygget matematiske operationer, som eksempelvis \sphinxcode{\sphinxupquote{cos}}, \sphinxcode{\sphinxupquote{sin}}, \sphinxcode{\sphinxupquote{sqrt}} mm., som også kan bruges på enten et enkelt tal, eller på et helt array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{36}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
6.0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{array\PYGZus{}af\PYGZus{}tal}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1., 2., 3., 4., 5.])
\end{sphinxVerbatim}

Yderligere benyttes numpy ofte til at regne statistik på et helt array, eksempelvis gennemsnittet af overstående array:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{array\PYGZus{}af\PYGZus{}tal}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
11.0
\end{sphinxVerbatim}

For en mere grundig gennemgang af numpy i MekRel\sphinxhyphen{}sammenhænge, se {\hyperref[\detokenize{notebooks/MekRel/Numpy::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{siden om numpy i MekRel}}}}.


\section{Matplotlib Pyplot}
\label{\detokenize{notebooks/Intro_til_pakker:matplotlib-pyplot}}
Matplotlib bruges til at plotte numeriske værdier fra eksempelvis laboratoriet. Vi importerer det ved:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

Herefter kan man nu benytte \sphinxcode{\sphinxupquote{plt.plot}} til at plotte datapunkter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Plot af punkter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Intro_til_pakker_25_0}.png}

Matplotlib kan desuden bruges til rigtig mange forskellige plottyper, og det er et super vigtigt værktøj i laboratoriet. Se hvordan det ellers bruges på {\hyperref[\detokenize{notebooks/MekRel/Matplotlib_pyplot::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{siden om matplotlib i MekRel}}}}.


\section{SymPy}
\label{\detokenize{notebooks/Intro_til_pakker:sympy}}
Når vi skal foretage symbolske udregninger såsom at udregne grænser, foretage differentialregning eller løse ligninger benytter vi SymPy.

Når vi benytter SymPy starter vi oftest med at gøre Python opmærksom på, at vi ikke har med numeriske værdier at gøre, men i stedet noget mere abstrakt, som altså ikke skal afrundes eller udregnes, men lige præcis behandles som et symbol.

For at starte op i SymPy importerer man biblioteket samt de symboler, som man gerne vil bruge fra \sphinxcode{\sphinxupquote{sympy.abc}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}                   \PYG{c+c1}{\PYGZsh{} Importer biblioteket}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{phi}   \PYG{c+c1}{\PYGZsh{} Og de symboler som vi vil bruge. Vi kan altid hente flere   }
\end{sphinxVerbatim}

Når man nu benytter sympy kan blot kombinerer symbolerne til nye udtryk.
Eksempelvis kan vi danne et udtryk  ved at gange og dividerer vores symboler med hinanden:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{/} \PYG{n}{x} 
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \frac{a b}{x}\end{split}
\end{equation*}
Eller vi kan sammensætte dette i nye udtryk, som vi nu kan behandle sammen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{phi} \PYG{o}{*}\PYG{o}{*} \PYG{n}{x} 

\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a b x\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \phi^{x}\end{split}
\end{equation*}
Her benytter vi \sphinxcode{\sphinxupquote{display()}} i stedet for \sphinxcode{\sphinxupquote{print()}}, da vi ikke vil have en tekst version af vores symboler, men i stedet fortæller vi jupyter, at symbolerne skal skrives. Vi kan nu kombinere de to udtryk med hinanden:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{*} \PYG{n}{g} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a b x \left(\phi^{x}\right)^{- a b x} - 1\end{split}
\end{equation*}
SymPy kommer nu også med en samling af funktioner, som vi kan bruge. Eksempelvis:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}                       \PYG{c+c1}{\PYGZsh{} Udtryk med cosinus}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Udtryk med ekspoential funktioner og kvadratrødder }
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \cos{\left(x \right)}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \phi^{x} + e^{2 a b x}\end{split}
\end{equation*}
Der, hvor vi virkelig får glæde af SymPy er, når vi benytte det til differentiering, integration og til eksempelvis at finde grænser. Hvis vi nu har funktionen:\( f(x) = \frac{x^2 - 4}{x + 2} \cdot e^{-x}\)

kan vi benytte sympy til at finde grænser for \(x \longrightarrow 2\)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}
\PYG{n}{f} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{limit}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 0\end{split}
\end{equation*}
Den afledte funktion:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \frac{2 x e^{- x}}{x + 2} - \frac{\left(x^{2} - 4\right) e^{- x}}{x + 2} - \frac{\left(x^{2} - 4\right) e^{- x}}{\left(x + 2\right)^{2}}\end{split}
\end{equation*}
Eller til integration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle - \left(1 - a\right) e^{- a} + \left(1 - b\right) e^{- b}\end{split}
\end{equation*}
For en nøjere gennemgang af SymPy og de mange andre muligheder, som det tilbyder, referer vi til {\hyperref[\detokenize{notebooks/sympy/Notebook1::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{noterne til python i LinAlys}}}}.


\chapter{Python i MekRel}
\label{\detokenize{notebooks/MekRel/Intro_til_MekRel:python-i-mekrel}}\label{\detokenize{notebooks/MekRel/Intro_til_MekRel::doc}}
Når I arbejder i laboratoriet i MekRel, bruges Python til at analysere jeres data og lave grafer til jeres rapport. Meget af
programmeringen vil ske i laboratoriet, hvor I arbejder i grupper. Husk dog at bytte rundt på rollerne i
gruppen, så alle får prøvet at kode i Python. Det er vigtigt, da I også skal lave fire individuelle Python
afleveringer i løbet af kurset. Python skal også bruges i jeres næste fag, Data og Projekt, hvor I skal lære
endnu mere om dataanalyse. Altså er det vigtigt at alle får prøvet kræfter og bliver fortrolig med Python
tidligt.

Det er vigtigt at understrege at I \sphinxstylestrong{ikke} skal bruge Jupyter Notebooks som logbøger til labafleveringer.
Logbøger eller rapporter skal ikke indeholde kode, kun resultatet af jeres kode (ex. plots og resultater), og kan
med fordel skrives i Word, LaTeX el.lign. og \sphinxstylestrong{skal} afleveres i .pdf\sphinxhyphen{}format. Derimod \sphinxstylestrong{må} nogle af de fire såkaldte
Pythonafleveringer, som afleveres individuelt, \sphinxstyleemphasis{godt} afleveres som Notebooks, men det hører I mere om
senere.

Et typisk arbejdsmønster når Python bliver brugt i MekRel, er at importere data og behandle det med \sphinxcode{\sphinxupquote{numpy}}
operationer og lave et plot med \sphinxcode{\sphinxupquote{matplotlib}} og derefter måske lave et fit med \sphinxcode{\sphinxupquote{scipy}}. Det anbefales derfor, at du først læser \sphinxcode{\sphinxupquote{numpy}}\sphinxhyphen{}noten og derefter \sphinxcode{\sphinxupquote{matplotlib}}\sphinxhyphen{}noten. \sphinxcode{\sphinxupquote{Scipy}}\sphinxhyphen{}noten er lidt mere teknisk og giver
bedst mening senere.


\section{Numpy}
\label{\detokenize{notebooks/MekRel/Numpy:numpy}}\label{\detokenize{notebooks/MekRel/Numpy::doc}}
Numpy bruges til at lave numeriske beregninger og vil være jeres primære værktøj i laboratoriet. Det skyldes at man kan bruge \sphinxcode{\sphinxupquote{numpy arrays}}. Det er en data type som gør operationer på mange tal hurtigt og forhåbenligt intuitivt når I har arbejdet lidt med det.

\sphinxstylestrong{Tip:} Hvis du gerne vil downloade og køre denne notebook skal du også bruge filen \sphinxcode{\sphinxupquote{Testdata.csv}} som kan hentes her \sphinxhref{https://github.com/JohannSeverin/NBI\_python/tree/main/notebooks/pakker}{link til host}


\subsection{Numpy arrays}
\label{\detokenize{notebooks/MekRel/Numpy:numpy-arrays}}
For at lave et numpy array kan man skrive forskellige ting. Her er nogle eksempler,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np} \PYG{c+c1}{\PYGZsh{} Husk at importere numpy ellers virker det ikke.}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}manuelt indtastede værdier}
\PYG{n}{array2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}et array med tallene fra 0 til 3 (ekslusiv 3) i 0.5 skridtstørrelse}
\PYG{n}{array3} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}et array med tallene fra 0 til 8 (inklusiv 8) i 5 skridt}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}ønsker du at se noget af det du har defineret så \PYGZdq{}print\PYGZdq{} det således}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array3}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3 4 5 1]
[0.  0.5 1.  1.5 2.  2.5]
[0. 2. 4. 6. 8.]
\end{sphinxVerbatim}

Læg mærke til at NumPy funktionen \sphinxcode{\sphinxupquote{arange}} tæller efter skridtstørrelse, altså hvor stort mellemrum der skal være mellem hver værdi i intervallet man angiver, og \sphinxcode{\sphinxupquote{linspace}} tæller efter, hvor mange skridt der skal være i alt, og giver så en jævn fordeling af værdier i det interval, man angiver.

Vil man gerne trække tal ud af sine arrays, gøres det ved at skrive indekset på det man gerne vil have ud,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array4} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}Definerer et array}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array4}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{array4}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{array4}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}vælger den første og tredje værdi i arrayet}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array4}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}vælger værdien fra indeks 1 til og uden 5 (husk at Python indekserer fra 0)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array4}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}man kan også vælge den sidste værdi ved at tælle baglæns}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3 4 5 1 6 8]
3 5
[4 5 1 6]
8
\end{sphinxVerbatim}

Man kan også lave arrays i 2D, og trække værdier ud på samme måde,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{array5} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}viser hele arrayet}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array5}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}udskriver indeks (1,1)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{array5}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}udskriver første kolonne i matricen}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{array5}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}bestemmer summen af alle tallene}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{array5}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}bestemmer summen af kolonnerne}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
5
[1 4 7]
45
[12 15 18]
\end{sphinxVerbatim}

En af grundene til at vi bruger NumPy arrays er, at vi nemt kan bruge NumPy funktioner til at lave regneoperationer på arrays. Her følger et par eksempler,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tal} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}heltal fra 0 til 9}

\PYG{n}{kvadrat} \PYG{o}{=} \PYG{n}{tal}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}tager kvadratet plus 1 for alle tal i arrayet}

\PYG{n}{Exp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{tal}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}tager exp til alle tal i arrayet}

\PYG{c+c1}{\PYGZsh{}printer array, og de to resultater}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{tal}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{kvadrat}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Exp}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0 1 2 3 4 5 6 7 8 9]
[ 1  2  5 10 17 26 37 50 65 82]
[1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01
 5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03
 2.98095799e+03 8.10308393e+03]
\end{sphinxVerbatim}


\subsection{Funktioner til statistik}
\label{\detokenize{notebooks/MekRel/Numpy:funktioner-til-statistik}}
Når vi laver databehandling i lab, skal vi ofte bruge gennemsnit og spredning på vores data, og det kan vi gøre nemt med et par \sphinxcode{\sphinxupquote{numpy}}\sphinxhyphen{}funktioner. Arbejder man med 2D\sphinxhyphen{}datasæt, f.eks. ved gentagne målinger for skiftende variable, hvor vi vil have gennemsnittet for hver opstilling, skal man være opmærksom på at indikere akse i datasættet. Aksen sættes enten til 0 eller 1, afhængig af om man vil tage gennemsnittet lodret gennem kolonner eller vandret gennem rækker.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,}\PYG{l+m+mf}{4.1}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{,}\PYG{l+m+mf}{4.3}\PYG{p}{,}\PYG{l+m+mf}{3.3}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}indtaster et datasæt}
\PYG{n}{gennemsnit1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{data1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}tager gennemsnit}
\PYG{n}{spredning1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{data1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}finder spredningen}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gennemsnit: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{gennemsnit1}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Spredning: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{spredning1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZbs{}n sætter blot det efterfølgende printet på ny linje}

\PYG{n}{data2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.2}\PYG{p}{,}\PYG{l+m+mf}{1.9}\PYG{p}{,}\PYG{l+m+mf}{3.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{3.4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}indtaster et 2D datasæt}
\PYG{n}{gennemsnit2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{data2}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}vi ønsker at tage gennemsnittet gennem kolonner. }
\PYG{n}{spredning2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{data2}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Det her er et 2D\PYGZhy{}array, }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{data2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gennemsnit: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gennemsnit2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Spredning: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{spredning2}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Gennemsnit:  3.72 
Spredning:  0.43081318457076023
Det her er et 2D\PYGZhy{}array, 
 [[1.  2.  3. ]
 [1.2 1.9 3.2]
 [0.8 2.1 3.4]]
Gennemsnit:  [1.  2.  3.2] 
Spredning:  [0.16329932 0.08164966 0.16329932]
\end{sphinxVerbatim}


\subsection{Importering af datafiler}
\label{\detokenize{notebooks/MekRel/Numpy:importering-af-datafiler}}
Når vi arbejder i lab har vi ofte et måleinstrument der tager målingerne, så det både er mere præcist og man kan tage flere målinger hurtigt.
Men når man gør det får man store mængder data og det gider vi ikke sidde og taste ind manuelt. Derfor vil vi bruge Python til det i stedet. For at gøre dette bruger vi igen NumPy pakken. Vi skal bruge kommandoen np.genfromtxt, syntaxen af denne er;

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{genfromtxt}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{delimiter} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{skip\PYGZus{}header} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{skip\PYGZus{}footer} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} 
\end{sphinxVerbatim}

hvor fname er filnavnet, delimiter er hvordan dataen er opdelt i filen (mere om det om lidt), skip\_header er hvor mange linjer af toppen af filen der skal springes over og skip\_footer er det samme bare fra bunden af. Dette er en forsimplet syntax. Den hele findes her hvis du gerne vil læse lidt mere \sphinxhref{https://numpy.org/doc/stable/reference/generated/numpy.genfromtxt.html}{np.genfromtxt syntax}. Den måde ‘=0’ skal forstås er at hvis du ikke skriver skip\_header=’noget’ så antager Python at du mener 0.

\sphinxstylestrong{Tip}: Det er vigtigt at datafilen som hedder fname ligger i den samme mappe som koden. Så sørg for at gemme jeres Notebook og datafil i samme mappe.

Her følger et eksempel, med datafilen “Testdata.csv” som kan hentes \sphinxhref{https://github.com/JohannSeverin/NBI\_python/tree/main/notebooks/pakker}{her}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{genfromtxt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testdata.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{delimiter} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{;}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{skip\PYGZus{}header}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}vores data er adskilt med semi\PYGZhy{}kolon, og vi springer 2 linjer over}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[ 1.2  2.5]
 [ 5.  10.3]
 [ 7.5 14.8]]
\end{sphinxVerbatim}

Inden man importerer datafilen er det vigtigt at kigge lidt på filen først. Det gør I ved at åbne jeres datafil i jeres foretrukne filredigeringsprogram. Hent den fil der hedder Testdata.csv som ligger \sphinxhref{https://github.com/JohannSeverin/NBI\_python/tree/main/notebooks/pakker}{her}, for at kunne kigge lidt på den og forstå importeringen. Hvis du åbner Testdata.csv, så kan du se at der er noget tekst allerøverst, derfor sætter vi skip\_header=2, da der er to linjer af tekst vi ikke vil have importeret i vores kode.
Videre ser vi at tallene er adskilt med semikolon. Det betyder at vi skal sætte delimiter = ‘;’. Udover det ser vi at vi får et todimensionelt array af data. Vi vil i dette tilfælde helst have kolonnerne hver for sig. En kolonne kan importeres således,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{kolonne1} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{kolonne1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1.2 5.  7.5]
\end{sphinxVerbatim}

Nu bør du kunne hente data fra en fil og begynde at lave små data behandlinger som at tage gennemsnittet af alle kolonnerne, under ses et eksempel på dette.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{genfromtxt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testdata.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{delimiter} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{;}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{skip\PYGZus{}header}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

\PYG{n}{Gns\PYGZus{}Row} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Gns\PYGZus{}Row}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[ 1.2  2.5]
 [ 5.  10.3]
 [ 7.5 14.8]]
[4.56666667 9.2       ]
\end{sphinxVerbatim}


\section{Matplotlib}
\label{\detokenize{notebooks/MekRel/Matplotlib_pyplot:matplotlib}}\label{\detokenize{notebooks/MekRel/Matplotlib_pyplot::doc}}
Vi vil ofte i lab gerne formidle vores data i form af en figur. For at lave figurer bruger vi pakken Matplotlib.

Matplotlib er et kæmpe bibliotek og kan rigtig rigtig meget. Det er faktisk så stort at du kun skal bruge en lille del af det \sphinxcode{\sphinxupquote{pyplot}}. Derfor skriver man \sphinxcode{\sphinxupquote{matplotlib.pyplot}}, det svarer lidt til kun at læse bøgerne i fysikafdelingen af et bibliotek.

Man skal også passe på, når man laver plots med matplotlib. Det mixer dårligt med \sphinxcode{\sphinxupquote{Sympy}}, da matplotlib laver plots ud fra tal og ikke analytiske udtryk, som er det Sympy giver. Hvis man skal lave et plot med Sympy så kig i noten om Sympy.


\subsection{Plots}
\label{\detokenize{notebooks/MekRel/Matplotlib_pyplot:plots}}
For at lave et plot skal vi først have data at arbejde med.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{xData} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{yData} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{1.8}\PYG{p}{,}\PYG{l+m+mf}{3.3}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Når man laver et plot med Matplotlib bygger man det op trinvis. Først laves plottet ud af data med \sphinxcode{\sphinxupquote{plt.plot}}. Derefter bygges aksenavne og en legend på. Et eksempel ses her,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xData}\PYG{p}{,} \PYG{n}{yData}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}Vi plotter xData mod yData som store prikker, og giver datasættet en titel}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Længde [cm]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}Tilføjer etiketter på akserne og angiver skriftstørrelse}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Masse [g]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fontsize} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize} \PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}plotter en \PYGZdq{}legend\PYGZdq{}, navnet hentes fra label i plt.plot}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}gemmer figuren som en .png fil}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}viser figuren under den kørte celle}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Matplotlib_pyplot_4_0}.png}

I behøver ikke nødvendigvis manuelt indstille skriftstørrelsen på akser og legend hver gang, men det kan nogle gange være nødvendigt at justere, afhængig af hvor meget figurerne skal fylde i jeres logbog. Regelen er at man altid skal kunne læse akse\sphinxhyphen{}titlerne uden at zoome ind eller hive forstørrelsesglas frem. Vær også opmærksom på, at når I bruger funktionen plt.savefig(), gemmes jeres figur i samme mappe som jeres Notebook ligger, medmindre I indstiller det anderledes.

Det kan også være smart at ændre hvad der er på akserne, et eksempel med radianer ses under.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}flere eksempler på at plotte}

\PYG{n}{xVærdi} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}laver et array af værdierne fra 0 til pi, fordelt over 100 datapunkter}

\PYG{c+c1}{\PYGZsh{}bruger NumPy funktioner til at plotte sinus og cosinus til vores x værdier, og indikerer at punkter skal være en }
\PYG{c+c1}{\PYGZsh{}prikket linje}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xVærdi}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{xVærdi}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f(x) = sin(x)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xVærdi}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{xVærdi}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f(x) = cos(x)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}sætter titler på akserne}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f(x)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Følgende skridt er lidt unødvendigt, men plotter man ex. trigonometriske funktioner kan det være fedt at indstille}
\PYG{c+c1}{\PYGZsh{} aksen så værdierne \PYGZdq{}giver mening\PYGZdq{} ift. funktionen.}
\PYG{c+c1}{\PYGZsh{} Her indikerer første array hvor på x\PYGZhy{}aksen man vil have \PYGZdq{}ticks\PYGZdq{}, og dernæst et array med hvad der skal stå på hvert}
\PYG{c+c1}{\PYGZsh{} \PYGZdq{}tick\PYGZdq{}}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xticks}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pi/2\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}3/2}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}2}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pi\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Matplotlib_pyplot_6_0}.png}

Det er en masse forskelige andre ting man kan med at plotte men dette bør være nok til det I skal her.


\section{Funktioner, fits og usikkerheder i Python}
\label{\detokenize{notebooks/MekRel/Funktioner_og_Scipy_optimize-checkpoint:funktioner-fits-og-usikkerheder-i-python}}\label{\detokenize{notebooks/MekRel/Funktioner_og_Scipy_optimize-checkpoint::doc}}
I denne note vil vi introducere jer til funktioner, hvordan man fitter en model til data og behandler usikkerheder i Python.


\subsection{Funktioner}
\label{\detokenize{notebooks/MekRel/Funktioner_og_Scipy_optimize-checkpoint:funktioner}}
Før vi kan fitte en funktion med Python skal vi kunne definere en funktion. En funktion er et meget bredt begreb i Python, og man kan rigtig meget med dem. Fordelen ved funktioner er, at man kan samle kode, som man bruger mange gange, så det kan gøre større projekter meget overskuelige. På nuværende tidspunkt er den primære brug af funktioner dog, at vi skal bruge dem til at fitte.

Man definerer en funktion ved at skrive

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{FUNKTION\PYGZus{}NAVN}\PYG{p}{(}\PYG{n}{INPUTS}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{\PYGZus{}\PYGZus{}Udregninger\PYGZus{}\PYGZus{}}
    \PYG{k}{return} \PYG{n}{OUTPUT}
\end{sphinxVerbatim}

Så en funktion bliver nu primært defineret ved input og outputtet af denn, hvor der så ligger en del udregninger imellem. Et eksempel kan ses nedenfor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{E\PYGZus{}kin}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{v}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Her har jeg defineret en funktion som jeg kalder E\_kin, den tager 2 argumenter, m og v, og returnerer \( \frac{1}{2}  m v^2\). Den kan vi så prøve af for m = 80 og v = 5

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{E\PYGZus{}kin}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1000.0
\end{sphinxVerbatim}

Funktioner kan også bruges til at gøre kode mere overskuelig og nemmere at debugge. Her er der fx defineret en funktion som laver et plot. Den tager ingen værdier og retunerer heller ikke noget, men er nem at debugge og man kan lade være med at kalde den, når man har fået sit plot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{v\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{E\PYGZus{}data} \PYG{o}{=} \PYG{n}{E\PYGZus{}kin}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{n}{v\PYGZus{}data}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}E\PYGZus{}kin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{v\PYGZus{}data}\PYG{p}{,}\PYG{n}{E\PYGZus{}data}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Energi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fart [m/s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Energi [J]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plot\PYGZus{}E\PYGZus{}kin}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Funktioner_og_Scipy_optimize-checkpoint_8_0}.png}


\subsection{Fitting}
\label{\detokenize{notebooks/MekRel/Funktioner_og_Scipy_optimize-checkpoint:fitting}}
Vi skal nu bruge funktioner til at fitte en model til data. Her bruger vi optimize.curve\_fit. Denne kommer fra pakken SciPy og importeres således:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{curve\PYGZus{}fit}
\end{sphinxVerbatim}

For at fitte en model skal man have noget data at fitte til. Her bruger jeg den data der lå på jeres første Python aflevering.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{0.19}\PYG{p}{,}\PYG{l+m+mf}{1.98}\PYG{p}{,}\PYG{l+m+mf}{2.05}\PYG{p}{,}\PYG{l+m+mf}{2.16}\PYG{p}{,}\PYG{l+m+mf}{2.16}\PYG{p}{,}\PYG{l+m+mf}{2.07}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{2.61}\PYG{p}{,}\PYG{l+m+mf}{2.6}\PYG{p}{,}\PYG{l+m+mf}{2.58}\PYG{p}{,}\PYG{l+m+mf}{2.81}\PYG{p}{,}\PYG{l+m+mf}{2.68}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{0.36}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{2.87}\PYG{p}{,}\PYG{l+m+mf}{2.97}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{0.53}\PYG{p}{,}\PYG{l+m+mf}{3.47}\PYG{p}{,}\PYG{l+m+mf}{3.83}\PYG{p}{,}\PYG{l+m+mf}{3.54}\PYG{p}{,}\PYG{l+m+mf}{3.6}\PYG{p}{,}\PYG{l+m+mf}{3.5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0.19 1.98 2.05 2.16 2.16 2.07]
 [0.3  2.61 2.6  2.58 2.81 2.68]
 [0.36 3.   3.   3.   2.87 2.97]
 [0.53 3.47 3.83 3.54 3.6  3.5 ]]
\end{sphinxVerbatim}

For at fitte en model til data, skal man have ét datapunkt for hver varieret måling. Her har vi 5 målinger per pendullængde, derfor skal vi altså tage gennemsnit af vores svingningstider.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:} \PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}udvælger kolonnen med pendullængde}
\PYG{n}{svingningstider} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}her udvælger vi de fire kolonner  med svingningstider}

\PYG{n}{gns\PYGZus{}svingning} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{svingningstider}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}tager gennemsnit af svingningstiderne, \PYGZdq{}axis\PYGZdq{} angiver om vi går vandret eller lodret i datasættet}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{gns\PYGZus{}svingning}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0.19 0.3  0.36 0.53]
[2.0875 2.65   2.9675 3.61  ]
\end{sphinxVerbatim}

Nu har vi to lister med datapunkter, der hænger sammen, og vi kan begynde at undersøge hvilket fit vi skal bruge. Vi regner med at skulle bruge en lineær funktion, så vi skal have defineret det i vores kode. Vi kalder funktionen “linfunc”, og angiver så variabel og parametre i parentes. I return skriver vi hvad funktionen skal give som resultat når vi bruger den.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{linfunc}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{a}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{n}{b}
    \PYG{k}{return} \PYG{n}{y}
\end{sphinxVerbatim}

Når man fitter er det meget \sphinxstylestrong{vigtigt} at det første argument i ens funktion, her x, er det som man har data på og vil have Python til at fitte efter, ellers fungerer fittet ikke. Dette er en fejl som ofte opstår, så hvis I får en fejl så tjek lige om i har det rigtige stående som det første I jeres parentes.

Når man så har en funktion defineret rigtigt, kan man fitte vores funktion til dataen med kommandoen \sphinxcode{\sphinxupquote{curve\_fit()}}. Funktionen \sphinxcode{\sphinxupquote{curve\_fit}} skal bruge funktionen, som vi ønsker at fitte, samt de tilhørende x\sphinxhyphen{} og y\sphinxhyphen{}værdier, som i dette tilfælde er pendullængde og svingningstid. Funktionen giver to outputs, først giver den fitte\sphinxhyphen{}parametrene, det vil sige fittets bedste bud på, hvad parametrene i fit\sphinxhyphen{}funktionen bør være. Dernæst giver den covariansen. Er der flere parametre angives covariansen som en matrix med flere værdier. Covariance\sphinxhyphen{}matrixen kan bruges til at finde ussikkerheder på fit parametre, men mere om det til sidst.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par}\PYG{p}{,} \PYG{n}{cov} \PYG{o}{=} \PYG{n}{curve\PYGZus{}fit}\PYG{p}{(}\PYG{n}{linfunc}\PYG{p}{,} \PYG{n}{L} \PYG{p}{,} \PYG{n}{gns\PYGZus{}svingning}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{par}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}printer parametrene}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cov}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}printer covariansen}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[4.4553719  1.29164669]
[[ 0.08314673 \PYGZhy{}0.02868562]
 [\PYGZhy{}0.02868562  0.01115413]]
\end{sphinxVerbatim}

Nu kan vi plotte vores data sammen med vores fit og vurderer, hvor god vores model er. Vi skal selvfølgelig også have plottet vores usikkerheder, og da vi arbejder med gennemsnit vil vi plotte usikkerheden ved hjælp af standardafvigelsen på vores data. Man kan bruge NumPy funktionen np.std() til at bestemme standardafvigelse.

For at plotte vores fit laver vi et array af værdier i det interval, som vi gerne vil plotte med np.linspace funktionen. Vi bruger så disse værdier i vores lineære funktion, hvor vi bruger de parametre vores fit bestemte med \sphinxcode{\sphinxupquote{curve\_fit}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{afvigelse} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{svingningstider}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{svingningstider}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{l+m+mf}{0.6}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}laver et array af 1000 jævnt fordelte tal mellem 0.1 og 0.6}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{linfunc}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{par}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{par}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}laver et array af vores lineære fit på det ovenstående array}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{L} \PYG{p}{,} \PYG{n}{gns\PYGZus{}svingning}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{Y} \PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{L} \PYG{p}{,} \PYG{n}{gns\PYGZus{}svingning} \PYG{p}{,} \PYG{n}{yerr}\PYG{o}{=}\PYG{n}{afvigelse} \PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Usikkerhed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Snorlængden [m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sviningstid [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Svingningstid som funktion af snorlængde}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Funktioner_og_Scipy_optimize-checkpoint_21_0}.png}

Man kan også lave et fit, hvor der tages højde for usikkerheden på datapunkterne. Det gør man ved at angive et sigma når man bruger curve\_fit.

\sphinxstylestrong{Tip:} Husk at bruge \sphinxcode{\sphinxupquote{absolute\_sigma = True}} ellers for i problemer med jeres ussikerheder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{par\PYGZus{}with\PYGZus{}error}\PYG{p}{,} \PYG{n}{cov\PYGZus{}new} \PYG{o}{=} \PYG{n}{curve\PYGZus{}fit}\PYG{p}{(}\PYG{n}{linfunc}\PYG{p}{,} \PYG{n}{L} \PYG{p}{,} \PYG{n}{gns\PYGZus{}svingning}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{afvigelse}\PYG{p}{,} \PYG{n}{absolute\PYGZus{}sigma} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{par\PYGZus{}with\PYGZus{}error}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[4.71061446 1.23176413]
\end{sphinxVerbatim}

Paremeterne er ikke ændret så meget da fejlen på punkterne er meget ens, men hvis der havde været stor forskel på usikkerhederne, ville det have en større effekt. Endeligt kan man så plotte punkter med usikkerheder og fit som tager højde for usikkerheden.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Y\PYGZus{}2} \PYG{o}{=} \PYG{n}{linfunc}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{par\PYGZus{}with\PYGZus{}error}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{par\PYGZus{}with\PYGZus{}error}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{L} \PYG{p}{,} \PYG{n}{gns\PYGZus{}svingning}\PYG{p}{,}\PYG{n}{yerr}\PYG{o}{=} \PYG{n}{afvigelse}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{Y\PYGZus{}2} \PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Snorlængden [m]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sviningstid [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Svingningstid som funktion af snorlængde}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Funktioner_og_Scipy_optimize-checkpoint_25_0}.png}

For at finde usikkerheden på de fittede parametre, kan man bruge covariance\sphinxhyphen{}matrixen. På dens diagonal er nemlig variansen for de fittede parametre. Når man har variansen kan man finde usikkerheden, da kvadratroden af variansen er ussikerheden. I Python kan det gøres med et for\sphinxhyphen{}loop.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{cov\PYGZus{}new}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{cov\PYGZus{}new}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{par}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ +/\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}
    
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
4.455371899695233  +/\PYGZhy{} 0.3624954078593303
1.2916466946051461  +/\PYGZhy{} 0.120762382852016
\end{sphinxVerbatim}

Her er fit\sphinxhyphen{}værdierne for a og b printet med usikkerheder fundet fra covariance\sphinxhyphen{}matrixen.


\chapter{Python i LinAlys}
\label{\detokenize{notebooks/sympy/Notebook1:python-i-linalys}}\label{\detokenize{notebooks/sympy/Notebook1::doc}}
LinALys\sphinxhyphen{}kurset indeholder to spor (analyse og lineær algebra) og har fokus på “blyantsregning” og forståelse af den bagvedliggende teori. Ind imellem får vi brug for et værktøj til at tegne funktioner og foretage både numeriske og symbolske beregninger for at illustrere en problemstilling og/eller støtte eller kontrollere beregningerne i hånden. I dette kursus har vi valgt at bruge Python\sphinxhyphen{}modulet SymPy som CAS\sphinxhyphen{}værktøj (Computer Algebra System). Python og SymPy er ikke nødvendigvis det optimale værktøj til alle de opgaver, vi løser med Python i kurset, men vi har valgt Python fordi det er standardprogrammeringssproget på fysikstudiets førstedel, så de kræfter, du kommer til at bruge på Python, får du forhåbentlig gavn af andre steder (f.eks. i MekRel\sphinxhyphen{}kurset). På denne side har vi samlet en række af forskellige noter, som forhåbentlig kan introducerer alt det Sympy, som I kan få brug for i LinAlys kurset.

Det er vigtigt at være opmærksom på, at modsat CAS\sphinxhyphen{}værktøjer som Maple, TI\_Nspire og WordMat, så er Python ikke lavet specifikt til symbolske udregninger, men er et generelt anvendeligt programmeringssprog. Man skal derfor vænne sig til både Pythons syntaks og programmering som helhed for at få det maksimale ud af SymPy. Når det til gengæld er klaret, er det muligt at benytte SymPy i en lang række sammenhænge, og f.eks. nemt skifte mellem numeriske og symbolske anvendelser. Dette vil vi vende tilbage til, når vi har forudsætningerne på plads.


\section{Hvad er SymPy?}
\label{\detokenize{notebooks/sympy/Notebook2:hvad-er-sympy}}\label{\detokenize{notebooks/sympy/Notebook2::doc}}
I denne sektion vil vi kigge på, hvordan vi benytter SymPy. Selve SymPy er en pakke i Python, der lader os arbejde med symbolske udtryk. Vi starter med at importere SymPy på samme måde. Derfor vil vi starte alle notebooks med at importere SymPy og benytte forkortelsen “sp” for pakken: import sympy as sp.SymPy har flere indbyggeret printe\sphinxhyphen{}værktøjer, der gør det muligt at se symbolske udtryk som LaTeX. Vi skal dog være opmærksom på, at den normale print() i Python printer output i “string”\sphinxhyphen{}format, mens funktionen display() (som er indbygget i Jupyter) vil være vores foretrukne valg til at vise SymPy\sphinxhyphen{}udtryk som LaTeX. \sphinxstyleemphasis{Hvis vi skriver udtrykket til sidst i en celle, vil Jupyter automatisk bruge \sphinxcode{\sphinxupquote{display}}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}                    \PYG{c+c1}{\PYGZsh{} Importer SymPy}
\end{sphinxVerbatim}


\subsection{Symboler og tal}
\label{\detokenize{notebooks/sympy/Notebook2:symboler-og-tal}}
På samme måde som vi kan have variable i Python som \sphinxstyleemphasis{strings}, logiske booleans eller talværdier, så tilføjer SymPy muligheden for symbolske variable, f.eks. svarende til hvad vi normalt kalder en ubekendt i ligningsløsning eller den (uafhængige) variabel i en funktion. Vi ønsker således at have muligheden for angive en variabel som \(x\) i \(f(x) = x^2+3x-2\) og opfatte den som et abstrakt objekt i modsætning til at tildele \(x\) en værdi. Den nemmeste måde at definere symboler på er at importere dem fra underbiblioteket sympy.abc, som indeholder de fleste symboler, som vi til dagligt bruger. Vi kan altså definere f.eks. \(x, a, b\) og \(\phi\) som symboler ved at skrive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{phi}
\end{sphinxVerbatim}

Nu kan vi benytte disse variable i beregninger:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{+} \PYG{n}{phi} \PYG{c+c1}{\PYGZsh{} Vi kan lægge dem sammen}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a + b + \phi\end{split}
\end{equation*}
Vi kan også danne nye udtryk med symbolske værdier. Udtrykkene kan sættes sammen ved at benytte normale Python\sphinxhyphen{}operationer såsom: +, \sphinxhyphen{}, *,/ eller **. Derudover kan vi benytte en del andre regneoperationer ved at skrive sp. foran operationen.
Her er samlet de typiske regneoperationer, som man kan finde i SymPy
\begin{itemize}
\item {} 
Kvadratrødder: sp.sqrt(x) (benyt \sphinxcode{\sphinxupquote{sp.root(x, n)}} til at tage n’te rod af x)

\item {} 
Trigonometriske funktioner: sp.cos(x), sp.sin(x), sp.tan(x). (de inverse findes ved eksempelvis acos(x))

\item {} 
Exponentialfunktion sp.exp(x)

\item {} 
Logaritmer: sp.log(x). For at få 10\sphinxhyphen{}talslogaritmefunktionen skrives log(x, 10)

\end{itemize}

En mere omfattende \sphinxhref{https://docs.sympy.org/latest/modules/functions/elementary.html}{liste over regneoperationer kan findes her.}

Så eksempelvis kan vi sammensætte et udtryk ved at benytte exponentialfunktionen sp.exp sammen med vores symboler:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{n}{phi}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a e^{\phi + 2 x}\end{split}
\end{equation*}
Vi kan også danne nye symbolske variable ud fra eksisterende variable. Vi kan f.eks. definere en funktion \(f\) baseret på tal og eksisterende symbolske variable:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{n}{phi}\PYG{p}{)}
\end{sphinxVerbatim}

Bemærk at vi ikke behøver at definere \(f\) som symbolsk variabel. Python/SymPy kan godt regne ud at f bliver en symbolsk variabel idet den er opbygget af andre symbolske variable. Resultatet kan vises med display()\sphinxhyphen{}funktionen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a e^{\phi + 2 x}\end{split}
\end{equation*}

\subsection{Eksakt repræsentation af tal}
\label{\detokenize{notebooks/sympy/Notebook2:eksakt-repraesentation-af-tal}}
Python opfatter / som en numerisk operation, og når vi vil have eksakte tal\sphinxhyphen{}brøker, må vi eksplicit bede SymPy om at opfatte dem som sådan ved hjælp af Rational(a, b)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{brøk} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{brøk}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \frac{1}{3}\end{split}
\end{equation*}
En brøk bestående bestående af symboler lider ikke under samme problem, så der kan vi bare bruge almindelig division.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c} \PYG{o}{=} \PYG{n}{a}\PYG{o}{/}\PYG{n}{b}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \frac{a}{b}\end{split}
\end{equation*}
Vi kan regne med brøkerne ved hjælp af de almindelige regnearter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{q} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{p} \PYG{o}{\PYGZhy{}} \PYG{n}{q}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{q} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n}{a}\PYG{o}{/}\PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{q}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle - \frac{1}{15}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \frac{a}{3 b} - \frac{2}{5}\end{split}
\end{equation*}
Vi får ofte brug for eksakte værdier af \(\pi\) og evt. andre særlige tal. En eksakt værdi af \(\pi\) får vi ved at skrive from sympy import pi. Når vi sammensætter symbolske variable og \(\pi\) med tal i brøker, kan vi som nævnt ovenfor godt bruge almindelige division istedet for sp.Rational(tæller, nævner), da Python på grund af symbolerne ikke kan behandle udtrykkene som numerisk repræsenterede tal (\sphinxstyleemphasis{floats}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{n}{value} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \frac{\sqrt{3} \pi}{2}\end{split}
\end{equation*}
Desuden kan vi hente nogle andre brugbare symboler fra SymPy, som eksempelvis uendelig, oo (der skrives som to små o’er og ligner et uendelighedstegn, hvis man har lidt fantasi).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{oo} \PYG{c+c1}{\PYGZsh{} Importer værdien uendelig}
\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{oo}               \PYG{c+c1}{\PYGZsh{} 1 divideret med uendelig giver 0, i hvert tilfælde for fysikere :o)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 0\end{split}
\end{equation*}
På samme måde kan vi også importere den imaginære enhed \(i = \sqrt{-1}\), som i SymPy er angivet ved et stort I. Hvis man hellere vil lave numeriske beregninger med komplekse tal, benytter man i stedet j og kan f.eks. skrive 2 + 3j. \sphinxstyleemphasis{Hvis du ikke kender til de komplekse tal, så gå ikke i panik. De bliver introduceret i slutningen af blok 1}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{I} \PYG{c+c1}{\PYGZsh{} Importer I}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{I}       \PYG{c+c1}{\PYGZsh{} definer to tal}
\PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{} Vi viser dem med display()}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 3 + 3 i\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle 1 - 2 i\end{split}
\end{equation*}
Vi vil vende tilbage til imaginære tal i SymPy i en senere notebook.


\subsection{Evaluer udtryk}
\label{\detokenize{notebooks/sympy/Notebook2:evaluer-udtryk}}
Forestil dig at vi har et symbolsk udtryk, der indeholder den variable \(a\), og vi ønsker at indsætte værdien \(a = 2\). Til dette vil vi nu indføre de to metoder .subs() og .evalf(). For et udtryk \(f\), som eksempelvis kunne være f = a ** 2 + b, kan vi indsætte \(a = 2\) ved at skrive f.subs(a, 2).

\sphinxstylestrong{Symbolsk substituering}:

Vi kunne for eksempel for et udtryk \(cos(x \cdot \pi / 4)\) ønske at finde værdien for forskellige værdier af x:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi definerer funktionen f:}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi kan nu finde værdien, hvis x var 2 ved at skrive:}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \cos{\left(\frac{\pi x}{4} \right)}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \frac{\sqrt{2}}{2}\end{split}
\end{equation*}
Vi kan også indsætte et udtryk ind i et andet:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}    \PYG{c+c1}{\PYGZsh{} Vi har allerede x, a, og b til rådighed fra ovenfor, men skal have c med.}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{*} \PYG{n}{x} \PYG{o}{+} \PYG{n}{x}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{b} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{c} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}

\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a b x + x\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle b^{2} + c^{2}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle a b \left(b^{2} + c^{2}\right) + b^{2} + c^{2}\end{split}
\end{equation*}
Her har vi altså defineret to udtryk og erstattet alle forekomster af x i det første udtryk med \(g = a^2 + b^2\). Vi kunne have opået det samme (nemmere, men mindre generelt) ved at skrive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{b} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{c} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{*} \PYG{n}{g} \PYG{o}{+} \PYG{n}{g}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a b \left(b^{2} + c^{2}\right) + b^{2} + c^{2}\end{split}
\end{equation*}
\sphinxstylestrong{Numerisk evaluering:}

Når vi har et matematisk udtryk, er det en fordel også at kunne finde en numerisk approksimation. Til at gøre dette benytter vi metoden .evalf(cifre), som giver en approksimation med det angivne antal cifre. Det simpleste eksempel er, hvis vi ønsker at finde det første 10 cifre af pi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pi}\PYG{o}{.}\PYG{n}{evalf}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} evalf(10), giver os de første 10 cifre}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 3.141592654\end{split}
\end{equation*}
Vi kan benytte de to metoder i kombination, hvis vi eksempelvis vil finde værdien af et udtryk og så approksimere det.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x} \PYG{o}{/} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}

\PYG{n}{f\PYGZus{}3} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Substituerer x med 3 og gemmer det i en variabel, der hedder f\PYGZus{}3.}
\PYG{c+c1}{\PYGZsh{} Det er sådan vi gerne vil have svaret skrevet i pointopgaverne i LinALys: så simpelt som muligt men stadig eksakt.}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f\PYGZus{}3}\PYG{p}{)}

\PYG{n}{f\PYGZus{}3}\PYG{o}{.}\PYG{n}{evalf}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Lad os finde værdien som decimaltal med 3 cifre.}
\PYG{c+c1}{\PYGZsh{} ... hvilket er praktisk f.eks. hvis vi skulle tegne resultatet ind i en illustration}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle e^{\frac{x}{5}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle e^{\frac{3}{5}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle 1.82\end{split}
\end{equation*}

\section{Grænser}
\label{\detokenize{notebooks/sympy/Notebook2_limits:graenser}}\label{\detokenize{notebooks/sympy/Notebook2_limits::doc}}
En anden anvendelse af symbolske udtryk er beregning af grænseværdier. Fokus i kurset er på beregning af grænseværdier med papir og blyant, men det er godt at kunne checke sine resultater eller lave mere avancerede beregninger med SymPy. Dette gøres relativt nemt ved at benytte sp.limit\sphinxhyphen{}funktionen. Kaldesekvensen for funktionen er
sp.limit(udtryk, variabel, grænse for variabel, retning). Efterlades retningen blank, beregnes grænseværdien oppefra / fra højre, og man får \sphinxstyleemphasis{ingen advarsel} selvom grænseværdierne fra henholdsvis højre og venstre er forskellige.

Hvis vi nu eksempelvis vil beregne \(\lim_{x\to 0} e^{-x}\) skriver vi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}            \PYG{c+c1}{\PYGZsh{} Hent sympy }
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}       \PYG{c+c1}{\PYGZsh{} Vi vil bruge `x`}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{oo}          \PYG{c+c1}{\PYGZsh{} Så kan vi tage grænserne i uendelig}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}                    \PYG{c+c1}{\PYGZsh{} Definer udtryk}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{limit}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Beregn og vis grænseværdien af udtrykket for x gående mod 0 oppefra ...}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{limit}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} ... og nedenfra}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 1\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle 1\end{split}
\end{equation*}
hvilket ikke er den store overraskelse, eftersom \(e^{-x}\) er defineret i \(x=0\), er kontinuert, og \(e^0=1\).

Vi kan også beregne grænseværdier for \(x\to\infty\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{limit}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{oo}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} grænsen af udtrykket for x gående mod uendelig. Vi angiver ingen retning.}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 0\end{split}
\end{equation*}
Vær særligt opmærksom på situationer, hvor grænseværdien kunne være forskellig oppefra og nedefra, hvilket oftest forkommer for udtryk på brøkform i det/de \(x\)\sphinxhyphen{}værdier, hvor nævneren antager værdien nul. Betragt f.eks. \(\displaystyle \frac{x^{4} + x^{2} + 1}{3 x^{3} - 19 x^{2} - x}\) når \(x \to 0\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Definer tæller og nævner hver for sig}
\PYG{n}{poly1} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{poly2} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{19} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}  \PYG{o}{\PYGZhy{}} \PYG{n}{x}

\PYG{c+c1}{\PYGZsh{} Kombiner dem til det ønskede udtryk og udskriv udtrykket til skærmen}
\PYG{n}{poly\PYGZus{}div} \PYG{o}{=} \PYG{n}{poly1} \PYG{o}{/} \PYG{n}{poly2}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{poly\PYGZus{}div}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Tag grænsen af udtrykket, når x går mod 0 først oppefra / fra højre }
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{limit}\PYG{p}{(}\PYG{n}{poly\PYGZus{}div}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \frac{x^{4} + x^{2} + 1}{3 x^{3} - 19 x^{2} - x}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle -\infty\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ... og dernæst nedefra / fra venstre:}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{limit}\PYG{p}{(}\PYG{n}{poly\PYGZus{}div}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \infty\end{split}
\end{equation*}

\section{Ligninger}
\label{\detokenize{notebooks/sympy/Notebook3_ligninger:ligninger}}\label{\detokenize{notebooks/sympy/Notebook3_ligninger::doc}}
Første trin for at løse ligninger er at få skrevet ligninger op i et sprog, Pyhton kan forstå. Det afgørende er her at indse at et lighedstegn kan have flere fundamentalt forskellige betydninger. Tidligere har vi tildelt variable bestemte værdier ved f.eks. at skrive k = 4, mens vi her vil bruge lighedstegnet til at beskrive et udsagn om sammenhængen mellem to udtryk. I SymPy\sphinxhyphen{}sprog er dette en \sphinxstyleemphasis{equality} og syntaksen er (når vi har importeret SymPy som sp som vi plejer) givet ved sp.Eq(venstre side, højre side). Pythagoras’ læresætning kan f.eks. opskrives som:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}             \PYG{c+c1}{\PYGZsh{} Vi definerer a, b og c som symbolske variable}

\PYG{n}{Pytha} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{a} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Syntaks: sp.Eq(venstre side, højre side)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Pytha}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a^{2} + b^{2} = c^{2}\end{split}
\end{equation*}
Man kan ligeledes danne ligninger ved at sammensætte allerede definerede udtryk, her eksemplificeret ved cosinusrelationen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{theta}

\PYG{n}{expr} \PYG{o}{=} \PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Vi laver nu blot den ene side af ligningen som et udtryk (\PYGZdq{}expression\PYGZdq{})}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{)}

\PYG{n}{cos\PYGZus{}relation} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{c}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{expr}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} Og vi kan nu sammensætte det}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{cos\PYGZus{}relation}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a^{2} - 2 a b \cos{\left(\theta \right)} + b^{2}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle c^{2} = a^{2} - 2 a b \cos{\left(\theta \right)} + b^{2}\end{split}
\end{equation*}
Nu når vi har lighederne på plads, er det blevet tid til at lade SymPy regne for os. SymPy giver os to forskellige værktøjer til at løse ligninger, og det er lidt forskelligt, hvad de hver især er gode til.


\subsection{Solveset}
\label{\detokenize{notebooks/sympy/Notebook3_ligninger:solveset}}
Den første metode hedder solveset(), som kan oversættes til “løsningsmængde”. Dette er den relativ ny metode, og SymPy\sphinxhyphen{}teamet arbejder på at denne skal være den primære løsningsmetode i fremtiden. Den løser dog ikke alle opgaver godt endnu, hvorfor vi nedenfor vil præsentere et alternativ.

Lad os prøve at løse en af overstående ligninger. Lad os tage helt standard Pythagoras \(a^2 + b^2 = c^2\) (ligningen defineret som Pytha ovenfor). Hvis vi nu  kender \(c=5\) og \(a=3\) og ønsker at finde \(b\), indsætter vi først værdierne i ligningen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Pytha}\PYG{p}{)}
\PYG{n}{Pytha\PYGZus{}indsat} \PYG{o}{=} \PYG{n}{Pytha}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Pytha\PYGZus{}indsat}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle a^{2} + b^{2} = c^{2}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle b^{2} + 9 = 25\end{split}
\end{equation*}
Vi benytter nu solveset() til at løse denne. For en ligning virker denne funktion ved, at man angiver ligningen og den variabel, som man ønsker at løse for:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solution} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{Pytha\PYGZus{}indsat}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{solution}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{-4, 4\right\}\end{split}
\end{equation*}
Vi har altså nu fundet løsningerne til ligningen. I tilfældet med Pythagoras’ sætning leder vi efter en sidelængde, så vores løsning skal være et positivt tal. Vi kan indskrænke løsningsdomænet ved at give solveset et “domain”\sphinxhyphen{}keyword. Dette skal være et såkaldt \sphinxstyleemphasis{SymPy\sphinxhyphen{}set}, som er en lidt indviklet størrelse, men i langt de fleste tilfælde kan man slippe afsted med at bede om reelle tal ved at skrive sp.Reals eller ved at give et interval med sp.Interval(\sphinxstyleemphasis{fra}, \sphinxstyleemphasis{til}), hvor man kan bruge oo for uendelig (forudsat at oo er blevet importeret). For mere avancerede løsningsdomæner henvises til dokumentationen \sphinxhref{https://docs.sympy.org/latest/modules/sets.html}{her}. I dette tilfælde angiver vi et interval:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{oo}           \PYG{c+c1}{\PYGZsh{} Vi importerer uendelig}
\PYG{n}{pos\PYGZus{}solution} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{Pytha\PYGZus{}indsat}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Interval}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{oo}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{pos\PYGZus{}solution}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{4\right\}\end{split}
\end{equation*}
solveset virker også hvis vi istedet for en ligning angiver et udtryk (altså uden lighedstegn). Da sætter SymPy udtrykket lig med 0 og løser den derved fremkomne ligning (i dette eksempel \(b^2-16 = 0\)):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pos\PYGZus{}solution} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Interval}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{oo}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{pos\PYGZus{}solution}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{4\right\}\end{split}
\end{equation*}
Vi vil bruge den samme syntaks her, hvor vi vil finde rødder i et fjerdegrads polynomium.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{solutions} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}Da vi har angivet et udtryk, sætter SymPy udtrykket lig med 0 og løser.}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{solutions}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{-1, 1, - i, i\right\}\end{split}
\end{equation*}
Er vi kun interesserede i reelle løsninger, kan vi indskrænke domænet til de reelle tal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solutions\PYGZus{}real} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Reals}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{solutions\PYGZus{}real}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{-1, 1\right\}\end{split}
\end{equation*}
Solveset virker også, hvis vi ikke har en numerisk værdi for alle symboler, men ønsker den generelle løsning. Hvis vi f.eks. vil finde \(b\) i cosinusrelationen som defineret tidligere, kan vi skrive følgende:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{cos\PYGZus{}relation}\PYG{p}{)}
\PYG{n}{sol\PYGZus{}b} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{cos\PYGZus{}relation}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sol\PYGZus{}b}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle c^{2} = a^{2} - 2 a b \cos{\left(\theta \right)} + b^{2}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \left\{a \cos{\left(\theta \right)} - \sqrt{a^{2} \cos^{2}{\left(\theta \right)} - a^{2} + c^{2}}, a \cos{\left(\theta \right)} + \sqrt{a^{2} \cos^{2}{\left(\theta \right)} - a^{2} + c^{2}}\right\}\end{split}
\end{equation*}
Solveset() giver os løsninger skrevet op i mængdenotation for at give os de generelle fuldstændige løsninger. Selvom dette kan være meget fint i nogle tilfælde, ender vi dog i andre tilfælde med en generel og ganske ubrugelig løsning. Dette sker eksempelvis, hvis vi prøver at løse for \(\theta\) direkte:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{cos\PYGZus{}relation}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{\theta \mid \theta \in \mathbb{C} \wedge - a^{2} + 2 a b \cos{\left(\theta \right)} - b^{2} + c^{2} = 0 \right\}\end{split}
\end{equation*}
Hvilket jo er rigtig nok (sammenlign med selve cosinusrelationen!), men ikke fortæller os så meget, vi ikke vidste i forvejen. Det leder os videre til den anden metode til ligningsløsning:


\subsection{Solve}
\label{\detokenize{notebooks/sympy/Notebook3_ligninger:solve}}
Solve() er den ældre funktion, som på trods af at være mindre generel oftest giver os en brugbar løsning. Syntaksen for input til Solve() er den samme som for Solveset()

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{cos\PYGZus{}relation}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZhy{}acos((a**2 + b**2 \PYGZhy{} c**2)/(2*a*b)) + 2*pi,
 acos((a**2 + b**2 \PYGZhy{} c**2)/(2*a*b))]
\end{sphinxVerbatim}

\sphinxstyleemphasis{Vær opmærksom på formatet, da vi her får en liste kan vi loope over den og bruge \sphinxcode{\sphinxupquote{display}} på løsninger}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sols} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{cos\PYGZus{}relation}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{løsning} \PYG{o+ow}{in} \PYG{n}{sols}\PYG{p}{:}
    \PYG{n}{display}\PYG{p}{(}\PYG{n}{løsning}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle - \operatorname{acos}{\left(\frac{a^{2} + b^{2} - c^{2}}{2 a b} \right)} + 2 \pi\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \operatorname{acos}{\left(\frac{a^{2} + b^{2} - c^{2}}{2 a b} \right)}\end{split}
\end{equation*}
Yderligere, kan vi angive et domæne for løsningen. I stedet kan man angive en liste af ligheder (eller uligheder), som afgrænser den variable. Hvis vi vil bestemme sidelængen \(b\) ved hjælp af Pythagoras’ sætning, vil opgaven i solve\sphinxhyphen{}sprog lyde:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Pytha\PYGZus{}indsat}\PYG{p}{)}
\PYG{n}{sol\PYGZus{}b} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Pytha\PYGZus{}indsat}\PYG{p}{,} \PYG{n}{b} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sol\PYGZus{}b}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle b^{2} + 9 = 25\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle b = 4\end{split}
\end{equation*}
Overordnet set er solve rigtig god til at give én løsning. Det kan altså ofte bruges i sammenhænge, hvor man vil tjekke et resultat, eller hvis man blot skal bruge en vilkårlig løsning og ikke den fuldstændige løsning.
Eksempel: Vi løser \(\sin(\theta) = 1\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[pi/2]
\end{sphinxVerbatim}

Her får vi altså en løsning, og det vil ofte være den løsning, vi leder efter. Men da \(\sin(x)\) er periodisk, ved vi, at der er flere løsninger. Så svaret er ikke fuldkomment.

I modsætning hertil har solveset den fordel, at den giver et  matematisk stringent svar, og den vil altså returnere hele løsningen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solveset}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \left\{2 n \pi + \frac{\pi}{2}\; |\; n \in \mathbb{Z}\right\}\end{split}
\end{equation*}

\subsection{Numerisk løsning}
\label{\detokenize{notebooks/sympy/Notebook3_ligninger:numerisk-losning}}
Nogle gange kan vi komme ud for en situation, hvor en opgave ikke har en brugbar eksakt, symbolsk løsning, eller at hverken solve eller solveset giver et svar, vi kan bruge. Vi kan så benytte sp.nsolve til numerisk løsning af ligninger. Vi bruger således SymPy (som er designet til at være et symbolsk værktøj) til et formål, der er på kanten af dets anvendelsesområde, og vi skal derfor bruge værktøjet med forsigtighed. Det er derfor en god idé i disse tilfælde at tegne grafer for at illustrere opgaven. Derved kan vi checke at svaret rent faktisk giver mening i forhold til opgaven, og det tillader os også at give et ret godt gæt på en løsning.

Derefter indskriver man den numeriske løsning som:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsolve}\PYG{p}{(}\PYG{n}{ligning}\PYG{p}{,} \PYG{n}{variabel}\PYG{p}{,} \PYG{n}{startgæt}\PYG{p}{)}
\end{sphinxVerbatim}

og dette vil nu prøve at udregne en numerisk værdi for en løsning.

Hvis nu vi eksempelvis vil finde en løsning til \(x\log(x) = \sin(x)\), starter vi med at lave et plot (se den anden Notebook til uge 3 for en mere grundig forklaring af syntaksen).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot}

\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_ligninger_34_0}.png}

Heraf ser vi altså, at et godt start gæt ville være omkring \(x=1.3\). Dette vil vi nu bruge.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lign} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{lign}\PYG{p}{)}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsolve}\PYG{p}{(}\PYG{n}{lign}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.3}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle x \log{\left(x + 1 \right)} = \sin{\left(x \right)}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle 1.1852999437201\end{split}
\end{equation*}
Sympy leder med \sphinxcode{\sphinxupquote{nsolve}} blot efter en løsning. Vi kan altså ende med at få forskellige svar alt efter, hvad vores startgæt er. Gætter vi \(x = 0.1\) får vi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsolve}\PYG{p}{(}\PYG{n}{lign}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle 1.64437672593563 \cdot 10^{-51}\end{split}
\end{equation*}
som er en numerisk værdi, som må betragtes som 0. Vi har altså her fundet den anden løsning. Det er derfor rigtig vigtigt at være opmærksom på, hvilken løsning vi kigger efter, og lave vores gæt efter dette.


\section{Plotting i SymPy}
\label{\detokenize{notebooks/sympy/Notebook3_plot:plotting-i-sympy}}\label{\detokenize{notebooks/sympy/Notebook3_plot::doc}}
Vi kan tegne grafer for funktioner og udtryk ved hjælp af SymPy. Det mest grundlæggende værktøj er funktionen plot, som vi importerer fra sympy.plotting her:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Den anbefalede standardblok for SymPy:}
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}                    \PYG{c+c1}{\PYGZsh{} Importer sympy}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}               \PYG{c+c1}{\PYGZsh{} Vi vælger at importere x som symbolsk variabel.}

\PYG{c+c1}{\PYGZsh{} Specifik import til plotteformål:}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot}
\end{sphinxVerbatim}

For at komme i gang vil vi gerne tegne grafen for en sinuskurve og definerer derfor først sinus som et udtryk:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

og tegner derefter ved at bruge funktionen plot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_6_0}.png}

Bemærk semikolonet, der beder Python om ikke at skrive outputtet, som her ville være en kode i stil med sympy.plotting.plot.Plot at 0x136af246608, som ikke er så relevant i denne kontekst.

Hvis man ønsker at tegne grafen for et bestemt \(x\)\sphinxhyphen{}interval, skriver man plot(udtryk, (variabel, start, slut)). Eksempel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_8_0}.png}

Man behøver naturligvis ikke at definere udtrykket først som en variabel, men kan skrive funktionen eller udtrykket direkte ind i plot. Hvis man ønsker at lave flere grafer i samme figur, kan man skrive plot(udtryk\_1, udtryk\_2, (variabel, start, slut)) som det fremgår her:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_10_0}.png}


\subsection{Parametre for Plot}
\label{\detokenize{notebooks/sympy/Notebook3_plot:parametre-for-plot}}
Udover at angive funktionen/udtrykket og afgrænsningen af den variable, kan man til plot angive en del andre oplysninger, som angives ved at tilføje keyword = værdi i slutningen af udtrykket. Nogle hyppigt anvendte keywords er:
\begin{itemize}
\item {} 
title angiver titlen på figuren. Angiv værdien som en string, altså som “Ønsket titel”

\item {} 
legend angiver om der skal stå en beskrivelse af graferne. Angiv i så fald værdien True

\item {} 
line\_color giver grafen en bestemt farve. Angiv værdien som en string, der indeholder en standardfarve, eksempelvis “red”, “green”, eller som en RGB\sphinxhyphen{}farvekode (r, g, b), hvor de tre værdier er mellem 0 og 1

\item {} 
xlim og ylim fastlægger aksernes afgrænsninger i hhv. vandret og lodret retning. Angiv to værdier (fra, til) for hver akse.

\item {} 
xlabel og ylabel sætter navne på hhv. \(x-\) og \(y-\)akse. Angiv som string.

\end{itemize}

Andre keywords kan findes i \sphinxhref{https://docs.sympy.org/latest/modules/plotting.html}{dokumentationen her}

Med disse muligheder kan vi forbedre vores seneste figur:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{,} 
     \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Harmoniske svingninger}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} 
     \PYG{n}{legend} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} 
     \PYG{n}{xlabel} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} 
     \PYG{n}{ylabel} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Amplitude}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_13_0}.png}

Den kompakte kommando til plotning af to grafer tillader desværre ikke umiddelbart at vi giver dem forskellige farver. For at gøre det, kan vi gemme selve figuren som et objekt med et navn ligesom en variabel, hvorefter det er muligt at ændre på de forskellige indstillinger:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi tegner en graf og navngiver resultatet som et objekt ved navn \PYGZdq{}figur\PYGZdq{}}
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_15_0}.png}

Når vi vil ændre indstillingerne for en eksisterende graf, er syntaksen figurnavn.keyword = ny\_værdi

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{legend} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Forskellige harmoniske svingninger}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{figur}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{line\PYGZus{}color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Der er flere kurver i figuren, og hver af dem har en farve. }
                             \PYG{c+c1}{\PYGZsh{} Kurverne har nummer 0, 1, 2, ... i den rækkefølge, de blev tegnet, så cosinus\PYGZhy{}kurven er 0}
\PYG{n}{figur}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{line\PYGZus{}color} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}  
                             \PYG{c+c1}{\PYGZsh{} ... og sinus er nummer 1. Her bruges RGB\PYGZhy{}farvekode. Farven er brun!}
                             
\PYG{c+c1}{\PYGZsh{} Efter at have ændret indstillingerne, beder vi Python om at opdatere figuren:}
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_17_0}.png}


\subsection{Figurer som lister}
\label{\detokenize{notebooks/sympy/Notebook3_plot:figurer-som-lister}}
I overstående eksempler har vi benyttet indeksering (som vi kender det fra lister) til at ændre på forskellige parametre. En af fordelene ved dette er at vi kan udvide vores figur ved brug af .append() og .extend() til at bygge videre på en figur, hvis vi ønsker at samle flere plots i en figur. Som eksempel vil vi bruge .append() til at tilføje en ekstra kurve til overstående figur.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n}{figur2} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{pi}\PYG{p}{)}\PYG{p}{,} \PYG{n}{line\PYGZus{}color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{legend} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_20_0}.png}

Denne kurve har nu fået objektnavnet figur2{[}0{]} fordi det er den første kurve i figuren, og vi kan nu tilføje den til figur ovenfor ved hjælp af append:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{figur2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_22_0}.png}

Hvis man vil kombinere figurer, som alle har flere kurver, kan man bruge .extend() til at tilføje alle plots fra en figur til den anden. Hvis figur2 således havde haft 2 kurver, ville vi kunne tilføje begge  til figur ved at skrive figur.extend(figur2).


\section{Gaffelfunktioner}
\label{\detokenize{notebooks/sympy/Notebook3_plot:gaffelfunktioner}}
Hvis vi ønsker at lave stykvis definerede funktioner, der har forskellige funktionsudtryk i forskellige intervaller (også kendt som “gaffelfunktioner”), kan vi benytte sp.Piecewise(). Syntaksen  er sp.Piecewise((udtryk1, intervalbetingelse1), (udtryk2, intervalbetingelse2)). Funktionen
\$\(f(x) = \begin{cases} -1 \quad &x < 4 \\ x - 5 \quad &x \geq 4\end{cases}\)\$
angives derfor som

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Piecewise}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{figur3} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaffelfunktion}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_25_0}.png}

sp.Piecewise kan arbejde med et større antal udtryk og intervalbetingelser end blot to som i eksemplet. Hvis nogle \(x\)\sphinxhyphen{}værdier opfylder flere af intervalbetingelserne, anvender SymPy det første udtryk hvor et givet \(x\) opfylder betingelsen. Man kan bruge dette på en smart måde hvis man skal tegne en gaffelfunktion, hvor samme udtryk gælder i flere intervaller for \(x\). Man kan eksempelvis lade det andet udtryk gælde alle steder, hvor den første ikke gælder, ved blot at angive andet udtryks intervalbetingelse som True og angive det som det sidste udtryk. Hvis forklaringen ikke er tydelig, håber vi at et eksempel kan hjælpe: Betragt funtionen
\$\(g_1(x) = \begin{cases} -2x \quad &x < -2 \\ x^2 \quad &-2\leq x\leq 2\\ 2x \quad &2 < x\quad \end{cases}\)\(
som kan skrives kortere som 
\)\(g_2(x) = \begin{cases} x^2 \quad &|x|\leq 2\\ 2|x| \quad &\mbox{ellers}\end{cases}\)\$
På samme måde kan denne funktion defineres i Python på 2 ækvivalente måder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g1} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Piecewise}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{g2} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Piecewise}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Bemærk at vi for andet udtryk med vilje}
\PYG{c+c1}{\PYGZsh{} ikke skriver nogen betingelse for x, men blot \PYGZsq{}True\PYGZsq{}, som altid er opfyldt, idet vi ønsker at bruge det}
\PYG{c+c1}{\PYGZsh{} andet udtryk når betingelsen for første udtryk (abs(x)\PYGZlt{}=2) ikke er opfyldt.}

\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaffelfunktion 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Vi ser kun en kurve, da udtrykkene er ens.}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_27_0}.png}

Angives udtrykkene derimod i omvendt rækkefølge, kommer udtrykket \(x^2\) aldrig i brug, da betingelsen True altid er opfyldt, og det er blot abs(x), dvs. \(|x|\), der tegnes

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Piecewise}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaffelfunktion (fejldefineret)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook3_plot_29_0}.png}

\sphinxstylestrong{Foreslået ændringer:}
Der er ret mange småting, som vi igen her med god grund kan indrage.
Christian er dog ret utilfreds med afsnittet med gaffel funktioner og vores differentiering af \(\frac{(x+2)(x-2)}{x+2} = x-2\quad,\)
Jeg er uenig i hans kommentarer, men vi kan godt bruge lidt energi på at gøre motivationen mere tydelig, da det for en fysikstuderende faktisk kan være ligegyldig (i langt de flest situationer), og at det kun er når man betragter nogle usædvanlige situationer i matematikken, at SymPy ikke nødvendigvis opfører sig som den skal.


\section{Differential\sphinxhyphen{} og integralregning for funktioner af en variabel}
\label{\detokenize{notebooks/sympy/Notebook4:differential-og-integralregning-for-funktioner-af-en-variabel}}\label{\detokenize{notebooks/sympy/Notebook4::doc}}
Vi vil i denne notebook gennemgå hvordan vi benytter SymPy til at differentiere og integrere funktioner af en variabel, samt hvordan vi bestemmer Taylorpolynomier.

For simpelhedens skyld vil vi i hele notebooken benytte \(x\) som den uafhængige variabel, mens \(a\), \(b\), \(A\) og \(\omega\) er konstanter. Vi starter med at importere SymPy og definere de variable

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}                         \PYG{c+c1}{\PYGZsh{} Importer sympy}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{omega}\PYG{p}{,} \PYG{n}{x}    \PYG{c+c1}{\PYGZsh{} Vi definerer vores symbolske variabel og konstanter}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{oo}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{I}                \PYG{c+c1}{\PYGZsh{} Vi importerer uendelig, pi og den imaginære konstant I }
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}                         \PYG{c+c1}{\PYGZsh{} Aktiver pretty\PYGZhy{}printing}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}        \PYG{c+c1}{\PYGZsh{} Hent vores printer til matematiske udtryk}
\end{sphinxVerbatim}


\section{Reduktion}
\label{\detokenize{notebooks/sympy/Notebook4:reduktion}}
SymPy viser differentierede eller integrerede funktioner på en måde, der nogle gange i højere grad afspejler den bagvedliggende algoritme end almindelig notationspraksis. Inden vi går i gang med at differentiere og integrere vil vi derfor først stifte bekendtskab med SymPys reduktions\sphinxhyphen{}værktøj.

En reduktion foretages i SymPy ved at bruge sp.simplify(udtryk).

Eksempel: Reducér \(2\cos^2(x) + \sin^2(x)\)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi definerer funktionen f:}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi reducere det nu}
\PYG{n}{f\PYGZus{}reduced} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{f\PYGZus{}reduced}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_6_0}.png}

\noindent\sphinxincludegraphics{{Notebook4_6_1}.png}

Bemærk først at SymPy viser ledene i det oprindelige udtryk i omvendt rækkefølge i forhold til hvordan vi skrev dem i definitionen. I reduktionstrinnet herefter anvender SymPy den trigonometriske identititet \(\cos^2(x) + sin^2(x) = 1\).

Hvad der udgør et optimalt reduceret udtryk afgøres af SymPys algoritmer, hvilket naturligvis ikke altid stemmer med vores egne præferencer.

Eksempel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{udtryk1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{udtryk1}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{udtryk1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_8_0}.png}

\noindent\sphinxincludegraphics{{Notebook4_8_1}.png}

SymPy foretrækker således denne form frem for den udgave, hvor parenteserne er ganget ud.
Hvis man ønsker et udtryk af en særlig form, findes der relaterede funktioner i SymPy, der laver omskrivninger til mere specifikke formater. \sphinxhref{https://docs.sympy.org/latest/tutorial/simplification.html}{Se en liste her}. I dette tilfælde kan man f.eks. bruge funktionen expand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{expand}\PYG{p}{(}\PYG{n}{udtryk1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_10_0}.png}

Hvis man blot skal tjekke et resultat uden at være interesseret i logikken bag omskrivningerne, kan det være praktisk at bruge det trick, som vi introducerer i eksemplet her:

Vi skal reducere udtrykket \((\frac{1}{2}x+3a+3b)^2 - (\frac{1}{2}x+a+b)^2\) i en pointopgave uden hjælpemidler, og genkender i et lyst øjeblik den såkaldte tredje kvadratsætning \((c+d)\cdot(c-d) = c^2-d^2\). Hvis vi sætter \(c=\frac{1}{2}x+3a+3b\) og \(d=\frac{1}{2}x+a+b\) får vi \((c+d)\cdot(c-d) = (x+4a+4b)\cdot(2a+2b)\). Det er nydeligt, men vi vil gerne tjekke med Python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{udtryk2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{udtryk2}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{expand}\PYG{p}{(}\PYG{n}{udtryk2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_12_0}.png}

\noindent\sphinxincludegraphics{{Notebook4_12_1}.png}

Dette er også et nydeligt udtryk, og uden at vi kender sammenhængen kan vi ikke afgøre hvilket et, der er det pæneste rent notationsmæssigt. Men hvis vi vil tjekke at de to udtryk er ens (f.eks. for at være sikker på at vi har regnet rigtigt), kunne vi nu gange \((x+4a+4b)\cdot(2a+2b)\) ud og sammenligne led, men vi kan også blot beregne forskellen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{udtryk3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{b}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{udtryk3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_14_0}.png}


\section{Differentiation}
\label{\detokenize{notebooks/sympy/Notebook4:differentiation}}
Syntaksen for differentiation ligner meget det, vi så, da vi beregnede grænseværdier i notebooken for uge 2. Vi benytter her funktionen sp.diff() og angiver udtryk og hvilken variabel, vi vil differentere efter: sp.diff(udtryk, variabel)

Hvis vi eksempelvis ønsker at differentiere \(\displaystyle b x^{a}\) med hensyn til \(x\), kan vi altså gøre følgende:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{b} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{n}{a}                \PYG{c+c1}{\PYGZsh{} Vi definerer udtrykket}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{)}

\PYG{n}{diff\PYGZus{}expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} Her differentieres det}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{diff\PYGZus{}expr}\PYG{p}{)} 
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_16_0}.png}

\noindent\sphinxincludegraphics{{Notebook4_16_1}.png}

Som kan simplificeres med sp.simplify():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{diff\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_18_0}.png}

Ønsker vi at differentiere en funktion flere gange, angiver vi blot antallet af gange, vi vil differentiere funktionen, som ekstra argument: sp.diff(udtryk, variabel, antalgange).

Eksempel: Lad os differentiere funktionen \(f(x) = A \cos(\omega x)\) med hensyn til \(x\) fem gange.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{A} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{omega} \PYG{o}{*} \PYG{n}{x}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} Definer udtrykket}
\PYG{n}{diff\PYGZus{}f5} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} Angiv differentieringen, med det ekstra argument: 5, for at differentiere fem gange}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{diff\PYGZus{}f5}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_20_0}.png}

Bemærk at SymPy godt kan snydes. Vi betragter f.eks. den stykvist lineære funktion fra notebooken i uge 3, og differentierer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Piecewise}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}

\PYG{n}{diff\PYGZus{}g} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{diff\PYGZus{}g}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot}
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{diff\PYGZus{}g}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gaffelfunktion}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\displaystyle \begin{cases} -1 & \text{for}\: x < 4 \\x - 5 & \text{otherwise} \end{cases}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle \begin{cases} 0 & \text{for}\: x < 4 \\1 & \text{otherwise} \end{cases}\end{split}
\end{equation*}
\noindent\sphinxincludegraphics{{Notebook4_22_2}.png}

Vi ser at SymPy håndterer differentiationen rimeligt godt, men at \(g'(4)\) angives til 1 selvom \(g\) ikke er differentiabel her. Den “lodrette del af grafen” ved \(x=4\) burde også vække vores mistanke.

Et andet relateret eksempel er funktionen \(h(x) = \frac{x^2-4}{x+2}\), som ikke er defineret for \(x=-2\) fordi nævneren da bliver nul, men som for \(x\neq-2\) kan reduceres ved hjælp af tredje kvadratsætning (idet tælleren omskrives \(x^2-4 = (x+2)(x-2)\)) til \(h(x) = x-2\). Vi beder SymPy om at differentiere hhv. med og uden efterfølgende reduktion af resultatet:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_24_0}.png}

\noindent\sphinxincludegraphics{{Notebook4_24_1}.png}

Vi ser at det første udtryk er korrekt, men at SymPy uden forbehold reducerer udtrykket uden hensyntagen til at \(h(x)\) slet ikke er defineret for \(x=-2\). Man skal altså selv være særlig opmærksom på punkter, hvor en givet funktion ikke er defineret eller ikke er differentiabel!


\subsection{Taylorudvikling}
\label{\detokenize{notebooks/sympy/Notebook4:taylorudvikling}}
Vi kan benytte SymPy til at lave en Taylorudvikling for en given funktion omkring et punkt \(x_0\). Dette gøres med sp.series(), der skal have argumenterne sp.series(funktionsudtryk, variabelnavn, x\_0, orden)  .Vi kan eksempevis udvikle \(e^{3x}\) omkring \(x_0=0\) til 5. orden ved at skrive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}                    \PYG{c+c1}{\PYGZsh{} Definer funktionsudtrykket. }
\PYG{n}{taylor\PYGZus{}exp} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{series}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Lav en taylorrække omkring x\PYGZus{}0 = 0 af udtrykket til 5. orden}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{taylor\PYGZus{}exp}\PYG{p}{)}                   \PYG{c+c1}{\PYGZsh{} Vis udtrykket}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_27_0}.png}

Et andet eksempel hvor leddene ikke præsenteres i samme logiske orden er udviklingen til 4. orden af funktionen \(f(x) = \frac{3}{1-3x}\) omkring \(x_0 = 1\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}                       \PYG{c+c1}{\PYGZsh{} Definer}
\PYG{n}{taylor\PYGZus{}expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{series}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Beregn taylorudviklingen / Taylorrækken}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{taylor\PYGZus{}expr}\PYG{p}{)}                     \PYG{c+c1}{\PYGZsh{} Vis}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_29_0}.png}

Hvis vi skal regne videre med dette udtryk uden restleddet eller tegne grafer, kan vi fjerne restleddet ved at skrive expr.removeO():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{taylor\PYGZus{}expr} \PYG{o}{=} \PYG{n}{taylor\PYGZus{}expr}\PYG{o}{.}\PYG{n}{removeO}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{taylor\PYGZus{}expr}\PYG{p}{)}                     \PYG{c+c1}{\PYGZsh{} Vis}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_31_0}.png}

Nu kan vi tegne grafen for Taylorapproximationen til \(f(x)\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot}   \PYG{c+c1}{\PYGZsh{} Importer plot\PYGZhy{}funktionen}

\PYG{c+c1}{\PYGZsh{} Vi genererer nu vores graf som en figur med passende titel og limits}
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{taylor\PYGZus{}expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{legend} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Taylorapproksimation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Taylor 4. orden}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_33_0}.png}

Vi tilføjer nu vores originale funktion for at sammenligne:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi laver nu en ny graf med den originale funktion.}
\PYG{c+c1}{\PYGZsh{} Bemærk, at vi skriver show = False for ikke at vise denne inden vi er færdige}
\PYG{n}{original} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{line\PYGZus{}color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi tilføjer vores original graf til vores figur ved at bruge .append() ... se notebooken fra uge 3 for en forklaring.}
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{original}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi skal nu tilpasse y.aksen, da det originale udtryk får meget store, negative værdier for x \PYGZhy{}\PYGZgt{} 1/3}
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{ylim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Til sidst viser vi figuren}
\PYG{n}{figur}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_35_0}.png}

Som ventet er Taylorapproximationen god i nærheden af udviklingspunktet \(x_0 = 1\).


\section{Integration}
\label{\detokenize{notebooks/sympy/Notebook4:integration}}
Fremgangsmåden for integration og differentiation minder utrolig meget om hinanden med den oplagte undtagelse, at man både kan beregne bestemte og og ubestemte integraler (altså hhv. med og uden grænser). Vi bruger funktionen sp.integrate. Et ubestemt integral findes ved sp.integrate(udtryk, variabel), mens bestemte integraler beregnes med sp.integrate(udtryk, (variabel, fra, til)). Bemærk at der skal en parentes omkring den variable og grænserne på samme måde som når man angiver et interval ved graftegning.

Vær opmærksom på, at SymPys integrationsresultater udelader den vilkårlige additive integrationskonstant.

Eksempel: Find stamfunktionen til \(x^4\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4}                               \PYG{c+c1}{\PYGZsh{} Definer udtryk}
\PYG{n}{stamfunktion\PYGZus{}expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Integrer udtrykket med hensyn til x}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{stamfunktion\PYGZus{}expr}\PYG{p}{)}                  \PYG{c+c1}{\PYGZsh{} vis}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_38_0}.png}

På samme måde findes det bestemte integral \(\int_0^{6\pi}(\sin(x))^2dx = \int_0^{6\pi}\sin^2(x)dx\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}                 \PYG{c+c1}{\PYGZsh{} Definer udtryk}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{o}{*} \PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Integrer udtrykket med hensyn til x fra 0 til 6 pi}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_40_0}.png}

Oftest kan det også være nyttigt at bruge enten algebraiske symboler eller eventuelt at integrere til uendelig. Her indskriver man bare dette i grænserne for sit bestemte integral.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi kan eventuelt udregne integralet for en gaussisk funktion}
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{oo}\PYG{p}{,} \PYG{n}{oo}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_42_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Eller vi kan integrere en polynomium fra a til b}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}

\PYG{n}{sp}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_43_0}.png}


\section{Alternativ Syntaks}
\label{\detokenize{notebooks/sympy/Notebook4:alternativ-syntaks}}
I løbet af denne Notebook har vi benyttet os af en forholdsvis stringent metode at skrive funktioner op på, som altid indeholder sp.funktion(). Mange af disse metoder er dog også allerede indbygget i de enkelte udtryks syntaks. Vi kan f.eks. i stedet for at skrive sp.simplify(expr) skrive expr.simplify(). Dette er en lille smutvej, men det giver nogle gange god mening at bruge. Herunder er vist nogle korte eksempler:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi viser, at man kan differentiere på følgende to ekvivalente måder:}
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_46_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_47_0}.png}

Ligeledes kan vi benytte simplify og integration på denne måde:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi simplificerer}
\PYG{n}{expr}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{p}{)}                   
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_49_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Beregner et bestemt integral}
\PYG{n}{expr}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}        
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_50_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Finder stamfunktion ved brug af integrate}
\PYG{n}{expr}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}                 
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook4_51_0}.png}


\section{Funktioner af flere variable}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:funktioner-af-flere-variable}}\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse::doc}}
\sphinxstylestrong{Foreslået ændringer}Jeg overvejer, om man skulle dele denne notebook op. Så der bliver en til flere variabel calculus og en til flere variabel plotting. Det ville give mere mening, når vi har denne nye struktur.
Til plottingdelen benytter Christian sig af en del tricks, som vi godt kan skrive ind. Vi skal dog bare lige være opmærksom på, om de bliver for avanceret.

Vi har nu udvidet vores funktionsdefinition til at omfatte funktioner af flere variable. Som udgangspunkt kan vi bruge Python/SymPy på samme måde som for funktioner af en variabel. Vi tilføjer dog de variable \(y\) og \(z\)  til vores standard startblok:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}                    \PYG{c+c1}{\PYGZsh{} Importer sympy}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{Matrix}              \PYG{c+c1}{\PYGZsh{} Importer den korte form at definere matricer på}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}         \PYG{c+c1}{\PYGZsh{} Vi henter vores variabler}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{oo}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{I}           \PYG{c+c1}{\PYGZsh{} Vi importerer uendelig, pi og den imaginære konstant I }
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}                    \PYG{c+c1}{\PYGZsh{} Aktiver pretty\PYGZhy{}printing}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}   \PYG{c+c1}{\PYGZsh{} Hent vores printer til matematiske udtryk}
\end{sphinxVerbatim}


\section{Differentiation af funktioner af flere variable}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:differentiation-af-funktioner-af-flere-variable}}
For funktioner af flere variable bliver diffentialkvotienterne \(f'\), \(f''\) afløst af lidt flere begreber. Vi vil i det følgende demonstrere hvordan man beregner partielt afledede, gradienter og Hesse\sphinxhyphen{}matricer (som dog først bliver berørt til sidst i LinAlys\sphinxhyphen{}kurset).


\subsection{Partielt afledede}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:partielt-afledede}}
Når vi går fra en til flere variable, spiller de partielt afledede en central rolle. De beregnes på en helt tilsvarende måde som vi tidligere har beregnet \(f'\), idet vi blot skal være opmærksomme på, hvilken variabel, vi differentiere i forhold til. Vi har også ved differentiation af funktioner af en variabel (se notebook til uge 4) angivet navnet på den variable, f.eks. sp.diff(expr, x), men dette var faktisk ikke strengt nødvendigt for simple funktioner, da SymPy i mange tilfælde kan gætte hvad der er den variable. Når vi har to variable, er det derimod afgørende at vi angiver den relevante variabel eksplicit.

Ellers foregår mange beregninger på samme måde:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} Vi definerer vores funktion af de to variable x og y}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{} Og differentierer, som vi plejer ift x}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{} Og i forhold til y}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_6_0}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_6_1}.png}

Derimod giver display(sp.diff(expr)) en fejlmeddelelse. Vi kan også differentiere flere gange efter hinanden i én kommando: Hvis vi f.eks. ønsker at udregne \(\frac{\partial^2}{\partial x \partial y}\left ( x^2\cdot e^y\right )\), skriver vi sp.diff(expr, y, x). Bemærk rækkefølgen af \(x\) og \(y\) her: i \(\frac{\partial^2}{\partial x \partial y}\) står \(\partial y\) bagerst, og logikken er, at da dette er nærmest funktionsudtrykket, skal vi differentiere efter \(y\) først. Mere formelt er \(\frac{\partial^2f}{\partial x \partial y} \equiv \frac{\partial}{\partial x}\left ( \frac{\partial f}{\partial y} \right )\). Syntaksen i Python er derimod at de variable skal listes  i differentiations/integrationsrækkefølgen i almindelig læseretning. Dette giver os:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_8_0}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_8_1}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_8_2}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_8_3}.png}


\subsection{Gradienter og retningsafledede}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:gradienter-og-retningsafledede}}
Et centralt begreb for funktioner af flere variable er gradienten, som vi skriver som \(\nabla f(x,y) = \left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)\). Vi tager altså den partielle differentieret i forhold til vores variable og sætter dem sammen som en vektor.

Der er flere måder at beregne gradienten på i Python/SymPy, men her vil vi anvende en måde, der læner sig op af den måde, vi udregner den på i hånden. Vi vil altså lave en vektor bestående af de forskellige partielt afledede. Vi gør dette med sp.derive\_by\_array(), der som input skal bruge en funktion og en liste af de variable, der skal differentieres efter.

Eksempel: Vi vil finde gradienten af \(f(x,y) = e^{- x^2 - y^2}\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{y} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{grad} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{derive\PYGZus{}by\PYGZus{}array}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_11_0}.png}

Resultatet kan umiddelbart aflæses, men hvis vi vil regne videre med gradienten som en vektor, bliver vi nødt til at benytte sp.Matrix() til at konvertere resultatet til matrixform, som vi kender fra notebooken om Linær Algebra.

Lad os nu eksempelvis beregne den retningsafledede for ovenstående funktion i retningen \(\left(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}\right)\) i punktet med \((x, y) = (1, 2)\). Vi beregner nu jvf. TK sætning 2.57:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grad\PYGZus{}vec} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{} Kovnerterer til vektor/matrix\PYGZhy{}format}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{grad\PYGZus{}vec}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} Vi viser det lige}

\PYG{c+c1}{\PYGZsh{} Vi definerer retningsvektoren i vektorformat}
\PYG{n}{retning} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{retning}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi beregner prikproduktet mellem gradienten med retningsvektoren}
\PYG{n}{prikket} \PYG{o}{=} \PYG{n}{grad\PYGZus{}vec}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{retning}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{prikket}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Vi indsætter x = 1 og y = 2 med .subs}
\PYG{n}{resultat} \PYG{o}{=} \PYG{n}{prikket}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{resultat}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_13_0}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_13_1}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_13_2}.png}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_13_3}.png}


\subsection{Hessematricen}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:hessematricen}}
Sidst i kurset vil vi bruge den såkaldte Hessematrix, der er en \(n\times n\)\sphinxhyphen{}matrix, der indeholder alle andenordens afledede for en funktion af \(n\) variable. Vi vil specielt bruge determinanten af Hessematricen til at undersøge opførslen af funktioner af 2 variables omkring et stationært punkt (se TK sætning 3.4, der som det fremgår af kommentaren lige under sætningen kan formuleres ved hjælp af Hessematricen).

Man kunne beregne Hessematricen ved at beregne de dobbelt afledede som beskrevet ovenfor, men det er nemmere at importere den fra underbiblioteket af SymPy, som hedder sympy.matrices med kommandoen from sympy.matrices import hessian. Vi kan nu benytte hessian(udtryk, variabelliste) på samme måde, som vi brugte sp.derive\_by\_array til at udregne gradienten:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{matrices} \PYG{k+kn}{import} \PYG{n}{hessian}        \PYG{c+c1}{\PYGZsh{} Importer Hessematricen}
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{y} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} Definer samme funktion som tidligere}

\PYG{n}{H} \PYG{o}{=} \PYG{n}{hessian}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{H}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_15_0}.png}

Og hvis vi nu vil beregne værdien for \((x, y) = (0, 1)\), kan vi benytte .subs() to gange:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{H}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_FlereVar_analyse_17_0}.png}


\section{Graftegning for funktioner af flere variable}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:graftegning-for-funktioner-af-flere-variable}}
Så snart man bevæger sig op i flere dimensioner, begynder det at blive sværere at visualisere de funktioner, man arbejder med. SymPy har en række indbyggede funktioner, der især kan hjælpe os med at analysere funktioner af 2 variable. Den flade, som repræsenterer en funktion af to variable kan tegnes i 3 dimensioner, og vi vil også give eksempler på hvordan man tegner konturplot og niveaukurver.


\subsection{Graftegning i 3D}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:graftegning-i-3d}}
For at tegne flader i 3D starter vi på samme måde som vi gjorde for 2D\sphinxhyphen{}tilfældet, men i stedet for at importere plot fra sympy.plotting, importerer vi nu i stedet plot3d. Herefter kan vi skrive plot3d(expr, (x, y)) eller f.eks. plot3d(expr, (x, \sphinxhyphen{}2, 2), (y, \sphinxhyphen{}2, 2)) hvis vi vil bestemme akseskaleringen. Der er oftest nødendigt at kunne rotere flader i 3D for at få et fyldestgørende indtryk af figures, så vi benytter her \%matplotlib notebook som gør vores figurer interaktiv. Hvis man eksempelvis vil plotte \(xy^2\) i området omkring origo, kan man gøre følgende:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot3d}         \PYG{c+c1}{\PYGZsh{} importer plot3d}
\PYG{c+c1}{\PYGZsh{} Aktiver interaktiv egentskab\PYGZsq{}}
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} notebook  

\PYG{n}{expr} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}                           \PYG{c+c1}{\PYGZsh{} Definer udtryk}
\PYG{n}{plot3d}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{\PYGZsh{} Plot med fastsatte akse\PYGZhy{}intervaller}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Python\sphinxhyphen{}SymPy\sphinxhyphen{}kombinationen har en meget uheldig svaghed her, idet det ikke umiddelbart er nemt at tilføje akselabels. Et workaround er at vælge forskellige akseskaleringer for \(x\)\sphinxhyphen{}aksen og \(y\)\sphinxhyphen{}aksen, så man kan se forskel også når man har roteret grafen.


\subsection{Konturer}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:konturer}}
Konturplot findes ved at lave en 2D\sphinxhyphen{}afbildning af værdien af den pågældende funktion af flere variable langs en linje. I tilfældet med en funktion af 2 variable ligger linjen i \(xy\)\sphinxhyphen{}planen, og konturen svarer til grafens skæring med den plan, der kan rejses vinkelret på \(xy\)\sphinxhyphen{}planen og som indeholder den pågældende linje. Se TK afsnit 1.2.1. De simpleste konturer fås ved at holde værdien af enten \(x\) eller \(y\) fast og så plotte \(f(x,y)\) som funktion af den anden variabel. Vi vil her følge TK eksempel 1.6 og betragter funktionen:
\$\(f(x,y) = 2x^2+ 4x - y^2 + 4y\)\(
Vi kan altså lave et konturplot ved at kigge på funktionens variation med \)x\( mens vi eksempelvis sætter \)y = 1\$:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot}

\PYG{c+c1}{\PYGZsh{} Definer funktion}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{y}

\PYG{c+c1}{\PYGZsh{} Lav et plot}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

For at få en fornemmelse af grafen for f, er et enkelt sådan snit ikke nok, så vi vil gerne lave en serie af konturplots. Vi kan her bruge PlotGrid fra sympy.plotting, som lader os sammensætte flere plots i en gitterstruktur. Vi bruger funktionen ved at at sige PlotGrid(antal\_rækker, antal\_kolonner, plot1, plot2 …)
Vi kan altså nu lave flere plots og så sætte dem sammen. Hvis vi nu vil lave seks plots hvor \(y = -1,...,4\) kan vi lave de enkelte grafen i en løkke og sætte dem sammen til sidst:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y\PYGZus{}værdier} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Definer liste}
\PYG{n}{figurer}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}           \PYG{c+c1}{\PYGZsh{} Tom liste til figurer}

\PYG{k}{for} \PYG{n}{y\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{y\PYGZus{}værdier}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} Pas på med at skrive y her, da vi allerede bruger den som symbol\PYGZhy{}variabel}
    \PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{y\PYGZus{}val}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Indsæt værdien af y og plot uden at vise grafen}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{axis\PYGZus{}center} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}                      \PYG{c+c1}{\PYGZsh{} For at gøre de enkelte grafer ens, sætter vi den samme akseskæring}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{xlim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}                           \PYG{c+c1}{\PYGZsh{} ... og samme akseafgrænsinger for x\PYGZhy{}aksen}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{ylim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}                         \PYG{c+c1}{\PYGZsh{} ... og y\PYGZhy{}aksen}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{y\PYGZus{}val}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{} Tilføj titel til plot}
    \PYG{n}{figurer}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{figur}\PYG{p}{)}                          \PYG{c+c1}{\PYGZsh{} Vi tilføjer figuren til en liste af figurer}
    
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{PlotGrid}            \PYG{c+c1}{\PYGZsh{} Importer gitterplottefunktion}
\PYG{n}{PlotGrid}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{*}\PYG{n}{figurer}\PYG{p}{)}\PYG{p}{;}                      \PYG{c+c1}{\PYGZsh{} Nu samler vi de 6 figurer i et gitterplot}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Det er værd at lægge mærke til at vi eskplicit sætter akseafgrænsningen til at være ens for alle 6 grafer. Ellers vil Python skalere dem fra figure til figur efter de enkelte grafers placering, hvilket vil gøre det svært at sammenligne de seks plots. Stjernen foran listen figurer svarer til figurer{[}0{]}, figurer{[}1{]} … , og er altså en genvej til at skrive alle elementerne i figurer op.

Vi kan nu gentage overstående, men skifte x\sphinxhyphen{}værdier:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x\PYGZus{}værdier} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} nu er det en liste af x\PYGZhy{}værdier}
\PYG{n}{figurer}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}     

\PYG{k}{for} \PYG{n}{x\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{x\PYGZus{}værdier}\PYG{p}{:}
    \PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x\PYGZus{}val}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Indsætter nu værdier for x i stedet}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{axis\PYGZus{}center} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}                      
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{xlim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}                           \PYG{c+c1}{\PYGZsh{} sæt nye mere passende grænser       }
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{ylim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}                         \PYG{c+c1}{\PYGZsh{} også her}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x\PYGZus{}val}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{} Skriv nu \PYGZdq{}x =\PYGZdq{} i titlen }
    \PYG{n}{figurer}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{figur}\PYG{p}{)}                          
    
\PYG{n}{PlotGrid}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{*}\PYG{n}{figurer}\PYG{p}{)}\PYG{p}{;}                      \PYG{c+c1}{\PYGZsh{} Nu samler vi de 6 figurer i et gitterplot}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Niveaukurver}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_analyse:niveaukurver}}
Mens konturer er snit mellem grafen for en funktion og “opretstående planer”, er niveaukurver snit med vandrette planer \(z=c\) (se TK 1.2.2). Vi vil altså tegne løsninger til \(f(x,y) = c\) i \(xy\)\sphinxhyphen{}planen. I SymPy kan vi få et hurtigt overblik ved at benytte funktionen plot\_contour (bemærk at plot\_contour her bliver brugt til at tegne niveaukurver og \sphinxstyleemphasis{ikke} konturplot) som importeres fra sympy.plotting.plot. Funktionen følger samme syntaks som 3dplot, og giver os et bud på, hvordan niveaukurverne ligger. Desværre har vi ret begrænsede muligheder for selv at vælge indstillinger for denne funktion.

Her undersøger vi (ligesom i TK 1.10) funktionen:
\$\( f(x, y) = x^2 + 4y^2 \)\$

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting}\PYG{n+nn}{.}\PYG{n+nn}{plot} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}contour}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{y} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{niveau} \PYG{o}{=} \PYG{n}{plot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Linjerne i plottet markere altså de sammenhængende \((x,y)\)\sphinxhyphen{}værdier, hvor \(f\) antager en bestemt værdi. Da funktionen her er meget ny i Python og ikke helt færdigudviklet, er det desværre ikke muligt at bestemme hvilken værdier, linjerne skal tegnes ved. Til gengæld har vi også muligheder for selv at gøre arbejdet. Vi kan nemlig benytte sympy til at tegne såkaldte implicitte udtryk, altså eksempelvis alle punkter i \(xy\)\sphinxhyphen{}planen, der opfylder, at \(f(x,y) = c\) for et givet c.

Vi betragter nu (jvf TK 1.11) \(f\) givet ved:
\$\(f(x,y) = x^2 - xy + y\)\$

Vi benytter plot\_implicit fra sympy.plotting til at finde niveaukurven for \(c = 3\). Vi danner først en ligning ved at skrive sp.Eq(udtryk, c) og så grænser for, hvor den skal plotte det henne, på samme måde som contour\_plot og plot3d.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y} \PYG{o}{+} \PYG{n}{y}

\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}implicit}
\PYG{n}{plot\PYGZus{}implicit}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Hvis vi vil tegne niveaukurve for værdier, vi selv kan bestemme, kan vi på samme måde som ved konturplottene lave en løkke, hvor vi går igennem de ønskede værdier:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c\PYGZus{}værdier} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Hvis vi vil tegne i samme figur, skal vi starte med at lave en figur. Lad os bare lave en figur med den første niveaukurve}
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot\PYGZus{}implicit}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{xlim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ylim}\PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{c\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{c\PYGZus{}værdier}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} loop over vores liste}
    \PYG{n}{ny\PYGZus{}figur} \PYG{o}{=} \PYG{n}{plot\PYGZus{}implicit}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{c\PYGZus{}val}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ny\PYGZus{}figur}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{figur}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Bemærk her, at vi egentlig plotter for \(c = 1\) to gange, første gang da vi opretter figuren, og derefter ved første gennemløb i løkken. Dette vil dog i næsten alle tilfælde ikke være et problem, da vi blot tegner den samme kurve to gange oveni hinanden. Hvis man ikke ønsker dette, kan man fjerne det første element for listen.

Vi ser at Python finder at \(f=1\) ikke kun er opfyldt langs linjerne \(x = 1\) og \(y=1+x\) (hvilket vi nemt kan indse ved at indsætte i udtrykket for \(f\)), men også i et område nær hvor disse to linjer krydser. Dette skyldes at Python/SumpY løser \(f(x,y)=c\) numerisk med en given (og tilsyneladende ikke ret høj) opløsning. Ved at betragte \(f\) i 3D kan vi se at funktionen rigtigt nok er meget flad omkring \((x,y)=(1,2)\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot3d}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{l+m+mf}{2.2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

For at plotte kurverne med \(f(x,y) = 1\) benytter vi at sympy bygger på matplotlib, så vi kan lave et numerisk plot ovenpå et sympy\sphinxhyphen{}plot ved at kalde figur.\_backend.ax{[}0{]}, hvorefter vi kan bruge plot(xs, ys, zs) fra matplotlib. SymPy\sphinxhyphen{}begyndere behøver ikke bekymre sig om detaljerne :o)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{u}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot3d\PYGZus{}parametric\PYGZus{}line}

\PYG{n}{xs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{ys} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{1.75}\PYG{p}{,} \PYG{l+m+mf}{2.25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}


\PYG{n}{figur}\PYG{o}{.}\PYG{n}{\PYGZus{}backend}\PYG{o}{.}\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}\PYG{p}{,} \PYG{n}{zs}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{xs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{ys} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{figur}\PYG{o}{.}\PYG{n}{\PYGZus{}backend}\PYG{o}{.}\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}\PYG{p}{,} \PYG{n}{zs}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{figur}\PYG{o}{.}\PYG{n}{\PYGZus{}backend}\PYG{o}{.}\PYG{n}{fig}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}


\section{Graftegning for funktioner af flere variable}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_plot:graftegning-for-funktioner-af-flere-variable}}\label{\detokenize{notebooks/sympy/Notebook_FlereVar_plot::doc}}
Så snart man bevæger sig op i flere dimensioner, begynder det at blive sværere at visualisere de funktioner, man arbejder med. SymPy har en række indbyggede funktioner, der især kan hjælpe os med at analysere funktioner af 2 variable. Den flade, som repræsenterer en funktion af to variable kan tegnes i 3 dimensioner, og vi vil også give eksempler på hvordan man tegner konturplot og niveaukurver.


\subsection{Graftegning i 3D}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_plot:graftegning-i-3d}}
For at tegne flader i 3D starter vi på samme måde som vi gjorde for 2D\sphinxhyphen{}tilfældet, men i stedet for at importere plot fra sympy.plotting, importerer vi nu i stedet plot3d. Herefter kan vi skrive plot3d(expr, (x, y)) eller f.eks. plot3d(expr, (x, \sphinxhyphen{}2, 2), (y, \sphinxhyphen{}2, 2)) hvis vi vil bestemme akseskaleringen. Der er oftest nødendigt at kunne rotere flader i 3D for at få et fyldestgørende indtryk af figures, så vi benytter her \%matplotlib notebook som gør vores figurer interaktiv. Hvis man eksempelvis vil plotte \(xy^2\) i området omkring origo, kan man gøre følgende:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot3d}         \PYG{c+c1}{\PYGZsh{} importer plot3d}
\PYG{c+c1}{\PYGZsh{} Aktiver interaktiv egentskab\PYGZsq{}}
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} notebook  

\PYG{n}{expr} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}                           \PYG{c+c1}{\PYGZsh{} Definer udtryk}
\PYG{n}{plot3d}\PYG{p}{(}\PYG{n}{expr}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{\PYGZsh{} Plot med fastsatte akse\PYGZhy{}intervaller}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Python\sphinxhyphen{}SymPy\sphinxhyphen{}kombinationen har en meget uheldig svaghed her, idet det ikke umiddelbart er nemt at tilføje akselabels. Et workaround er at vælge forskellige akseskaleringer for \(x\)\sphinxhyphen{}aksen og \(y\)\sphinxhyphen{}aksen, så man kan se forskel også når man har roteret grafen.


\subsection{Konturer}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_plot:konturer}}
Konturplot findes ved at lave en 2D\sphinxhyphen{}afbildning af værdien af den pågældende funktion af flere variable langs en linje. I tilfældet med en funktion af 2 variable ligger linjen i \(xy\)\sphinxhyphen{}planen, og konturen svarer til grafens skæring med den plan, der kan rejses vinkelret på \(xy\)\sphinxhyphen{}planen og som indeholder den pågældende linje. Se TK afsnit 1.2.1. De simpleste konturer fås ved at holde værdien af enten \(x\) eller \(y\) fast og så plotte \(f(x,y)\) som funktion af den anden variabel. Vi vil her følge TK eksempel 1.6 og betragter funktionen:
\$\(f(x,y) = 2x^2+ 4x - y^2 + 4y\)\(
Vi kan altså lave et konturplot ved at kigge på funktionens variation med \)x\( mens vi eksempelvis sætter \)y = 1\$:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot}

\PYG{c+c1}{\PYGZsh{} Definer funktion}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{y} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{y}

\PYG{c+c1}{\PYGZsh{} Lav et plot}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

For at få en fornemmelse af grafen for f, er et enkelt sådan snit ikke nok, så vi vil gerne lave en serie af konturplots. Vi kan her bruge PlotGrid fra sympy.plotting, som lader os sammensætte flere plots i en gitterstruktur. Vi bruger funktionen ved at at sige PlotGrid(antal\_rækker, antal\_kolonner, plot1, plot2 …)
Vi kan altså nu lave flere plots og så sætte dem sammen. Hvis vi nu vil lave seks plots hvor \(y = -1,...,4\) kan vi lave de enkelte grafen i en løkke og sætte dem sammen til sidst:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y\PYGZus{}værdier} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Definer liste}
\PYG{n}{figurer}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}           \PYG{c+c1}{\PYGZsh{} Tom liste til figurer}

\PYG{k}{for} \PYG{n}{y\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{y\PYGZus{}værdier}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} Pas på med at skrive y her, da vi allerede bruger den som symbol\PYGZhy{}variabel}
    \PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{y\PYGZus{}val}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Indsæt værdien af y og plot uden at vise grafen}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{axis\PYGZus{}center} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}                      \PYG{c+c1}{\PYGZsh{} For at gøre de enkelte grafer ens, sætter vi den samme akseskæring}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{xlim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}                           \PYG{c+c1}{\PYGZsh{} ... og samme akseafgrænsinger for x\PYGZhy{}aksen}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{ylim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}                         \PYG{c+c1}{\PYGZsh{} ... og y\PYGZhy{}aksen}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{y\PYGZus{}val}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{} Tilføj titel til plot}
    \PYG{n}{figurer}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{figur}\PYG{p}{)}                          \PYG{c+c1}{\PYGZsh{} Vi tilføjer figuren til en liste af figurer}
    
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{PlotGrid}            \PYG{c+c1}{\PYGZsh{} Importer gitterplottefunktion}
\PYG{n}{PlotGrid}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{*}\PYG{n}{figurer}\PYG{p}{)}\PYG{p}{;}                      \PYG{c+c1}{\PYGZsh{} Nu samler vi de 6 figurer i et gitterplot}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Det er værd at lægge mærke til at vi eskplicit sætter akseafgrænsningen til at være ens for alle 6 grafer. Ellers vil Python skalere dem fra figure til figur efter de enkelte grafers placering, hvilket vil gøre det svært at sammenligne de seks plots. Stjernen foran listen figurer svarer til figurer{[}0{]}, figurer{[}1{]} … , og er altså en genvej til at skrive alle elementerne i figurer op.

Vi kan nu gentage overstående, men skifte x\sphinxhyphen{}værdier:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x\PYGZus{}værdier} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} nu er det en liste af x\PYGZhy{}værdier}
\PYG{n}{figurer}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}     

\PYG{k}{for} \PYG{n}{x\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{x\PYGZus{}værdier}\PYG{p}{:}
    \PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{subs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x\PYGZus{}val}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Indsætter nu værdier for x i stedet}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{axis\PYGZus{}center} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}                      
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{xlim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}                           \PYG{c+c1}{\PYGZsh{} sæt nye mere passende grænser       }
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{ylim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}                         \PYG{c+c1}{\PYGZsh{} også her}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x\PYGZus{}val}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{} Skriv nu \PYGZdq{}x =\PYGZdq{} i titlen }
    \PYG{n}{figurer}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{figur}\PYG{p}{)}                          
    
\PYG{n}{PlotGrid}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{*}\PYG{n}{figurer}\PYG{p}{)}\PYG{p}{;}                      \PYG{c+c1}{\PYGZsh{} Nu samler vi de 6 figurer i et gitterplot}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Niveaukurver}
\label{\detokenize{notebooks/sympy/Notebook_FlereVar_plot:niveaukurver}}
Mens konturer er snit mellem grafen for en funktion og “opretstående planer”, er niveaukurver snit med vandrette planer \(z=c\) (se TK 1.2.2). Vi vil altså tegne løsninger til \(f(x,y) = c\) i \(xy\)\sphinxhyphen{}planen. I SymPy kan vi få et hurtigt overblik ved at benytte funktionen plot\_contour (bemærk at plot\_contour her bliver brugt til at tegne niveaukurver og \sphinxstyleemphasis{ikke} konturplot) som importeres fra sympy.plotting.plot. Funktionen følger samme syntaks som 3dplot, og giver os et bud på, hvordan niveaukurverne ligger. Desværre har vi ret begrænsede muligheder for selv at vælge indstillinger for denne funktion.

Her undersøger vi (ligesom i TK 1.10) funktionen:
\$\( f(x, y) = x^2 + 4y^2 \)\$

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting}\PYG{n+nn}{.}\PYG{n+nn}{plot} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}contour}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{y} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{n}{niveau} \PYG{o}{=} \PYG{n}{plot\PYGZus{}contour}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Linjerne i plottet markere altså de sammenhængende \((x,y)\)\sphinxhyphen{}værdier, hvor \(f\) antager en bestemt værdi. Da funktionen her er meget ny i Python og ikke helt færdigudviklet, er det desværre ikke muligt at bestemme hvilken værdier, linjerne skal tegnes ved. Til gengæld har vi også muligheder for selv at gøre arbejdet. Vi kan nemlig benytte sympy til at tegne såkaldte implicitte udtryk, altså eksempelvis alle punkter i \(xy\)\sphinxhyphen{}planen, der opfylder, at \(f(x,y) = c\) for et givet c.

Vi betragter nu (jvf TK 1.11) \(f\) givet ved:
\$\(f(x,y) = x^2 - xy + y\)\$

Vi benytter plot\_implicit fra sympy.plotting til at finde niveaukurven for \(c = 3\). Vi danner først en ligning ved at skrive sp.Eq(udtryk, c) og så grænser for, hvor den skal plotte det henne, på samme måde som contour\_plot og plot3d.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{x} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y} \PYG{o}{+} \PYG{n}{y}

\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}implicit}
\PYG{n}{plot\PYGZus{}implicit}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Hvis vi vil tegne niveaukurve for værdier, vi selv kan bestemme, kan vi på samme måde som ved konturplottene lave en løkke, hvor vi går igennem de ønskede værdier:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c\PYGZus{}værdier} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Hvis vi vil tegne i samme figur, skal vi starte med at lave en figur. Lad os bare lave en figur med den første niveaukurve}
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot\PYGZus{}implicit}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{xlim} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ylim}\PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{c\PYGZus{}val} \PYG{o+ow}{in} \PYG{n}{c\PYGZus{}værdier}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} loop over vores liste}
    \PYG{n}{ny\PYGZus{}figur} \PYG{o}{=} \PYG{n}{plot\PYGZus{}implicit}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{c\PYGZus{}val}\PYG{p}{)}\PYG{p}{,} \PYG{n}{show} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
    \PYG{n}{figur}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ny\PYGZus{}figur}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{figur}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

Bemærk her, at vi egentlig plotter for \(c = 1\) to gange, første gang da vi opretter figuren, og derefter ved første gennemløb i løkken. Dette vil dog i næsten alle tilfælde ikke være et problem, da vi blot tegner den samme kurve to gange oveni hinanden. Hvis man ikke ønsker dette, kan man fjerne det første element for listen.

Vi ser at Python finder at \(f=1\) ikke kun er opfyldt langs linjerne \(x = 1\) og \(y=1+x\) (hvilket vi nemt kan indse ved at indsætte i udtrykket for \(f\)), men også i et område nær hvor disse to linjer krydser. Dette skyldes at Python/SumpY løser \(f(x,y)=c\) numerisk med en given (og tilsyneladende ikke ret høj) opløsning. Ved at betragte \(f\) i 3D kan vi se at funktionen rigtigt nok er meget flad omkring \((x,y)=(1,2)\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figur} \PYG{o}{=} \PYG{n}{plot3d}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{l+m+mf}{2.2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

For at plotte kurverne med \(f(x,y) = 1\) benytter vi at sympy bygger på matplotlib, så vi kan lave et numerisk plot ovenpå et sympy\sphinxhyphen{}plot ved at kalde figur.\_backend.ax{[}0{]}, hvorefter vi kan bruge plot(xs, ys, zs) fra matplotlib. SymPy\sphinxhyphen{}begyndere behøver ikke bekymre sig om detaljerne :o)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{u}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{plotting} \PYG{k+kn}{import} \PYG{n}{plot3d\PYGZus{}parametric\PYGZus{}line}

\PYG{n}{xs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{ys} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{1.75}\PYG{p}{,} \PYG{l+m+mf}{2.25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}


\PYG{n}{figur}\PYG{o}{.}\PYG{n}{\PYGZus{}backend}\PYG{o}{.}\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}\PYG{p}{,} \PYG{n}{zs}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{xs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{ys} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{figur}\PYG{o}{.}\PYG{n}{\PYGZus{}backend}\PYG{o}{.}\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}\PYG{p}{,} \PYG{n}{zs}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{figur}\PYG{o}{.}\PYG{n}{\PYGZus{}backend}\PYG{o}{.}\PYG{n}{fig}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\sphinxstylestrong{Foreslået ændringer}I denne notebook skal der nok kun foretages småændringer, så den er konsistent med resten. Vi skal lige overveje, om det giver mening at have disse kapitler sammen, eller om det skal splittes yderligere. Jeg tænker primært på, at man skal kunne finde rundt i Notebooks, så vi skal nok have en bedre titel end indledende og avanceret, så man kan finde ud af, om eksempelvis en invers matrix er i den ene eller i den anden.


\section{Vektorer og matricer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:vektorer-og-matricer}}\label{\detokenize{notebooks/sympy/Notebook_LinAlg1::doc}}
I denne notebook vil vi have fokus på hvordan man definerer, manipulerer og foretager forskellige udregninger med matricer og vektorer. Som altid starter vi med at importere de relevante moduler og aktiverer funktionen til visning af matematiske udtryk:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}                    \PYG{c+c1}{\PYGZsh{} Importer sympy}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{oo}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{I}           \PYG{c+c1}{\PYGZsh{} Vi importerer uendelig, pi og den imaginære konstant I }
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}                    \PYG{c+c1}{\PYGZsh{} Aktiver pretty\PYGZhy{}printing}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}   \PYG{c+c1}{\PYGZsh{} Hent vores printer til matematiske udtryk}
\end{sphinxVerbatim}


\subsection{Vektorer og matricer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:id1}}
Det grundlæggende er at definere matricer og vektorer på den nemmeste måde. Dette gøres ved at benytte den funktion, der hedder Matrix() fra SymPy. Da man oftest skal bruge denne mange gange, kan det være praktisk at importere den særskilt ved at skrive from sympy import Matrix, men det er lige så fint at skrive sp.Matrix().


\subsubsection{Vektorer \sphinxhyphen{} definition og regneoperationer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:vektorer-definition-og-regneoperationer}}
Vektorer defineres ved at give en liste til Matrix funktionen. Vi kan altså skrive Matrix({[}1, 1, 0{]}) for at få vektoren:
\$\(\displaystyle \left[\begin{matrix}1\\1\\0\end{matrix}\right]\)\$

Vi kan angive de enkelte indgange som tal eller bruge symbolske variable som vi i forvejen har importeret fra \sphinxstyleemphasis{sympy.abc} ligesom vi tidligere har gjort med \(x\).

Eksempel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{Matrix}
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}

\PYG{n}{vektor1} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{vektor1}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_7_0}.png}

Det ligger os selvfølgelig også frit for at kombinere tal og variable:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vektor2} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Husk at bruge sp.Rational() til at definere brøker}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{vektor2}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_9_0}.png}

De to vektorer vektor og vektor2 kan nu kombineres på sædvanlig vis ved addition, subtraktion og skalarmultiplikation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vektor1} \PYG{o}{+} \PYG{n}{vektor2}   \PYG{c+c1}{\PYGZsh{} Blot læg de to vektorer sammen med et almindeligt +}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_11_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{*} \PYG{n}{vektor2}       \PYG{c+c1}{\PYGZsh{} a er importeret som et symbol, så vi kan bruge det som en skalar}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_12_0}.png}

Hvis vi til gengæld forsøger at multiplicere de to vektorer får vi en fejl, da * mellem to Matrix\sphinxhyphen{}elementer er matrix\sphinxhyphen{}multiplikation, som ikke er defineret for to 3 x 1 matricer. Vi vender tilbage til matrixmultiplikation nedenfor, mens krydsprodukter (også kendt som vektor\sphinxhyphen{}produkter) må vente til den næste notebook om lineær algebra.

Et produkt, der derimod \sphinxstyleemphasis{er} defineret for vektorer, er det fra gymnasiet velkendte skalarprodukt eller prikprodukt \(\mathbf{v_1} \cdot \mathbf{v_2}\) som er et eksempel på et indre produkt (i Messers notation \(\langle \mathbf{v_1}, \mathbf{v_2}\rangle\)).

Et indre produkt mellem to vektorer vektor1 og vektor2 beregnes med vektor1.dot(vektor2):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vektor1}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{vektor2}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_14_0}.png}

Som forventet får vi summen af produkterne af vektorens indgange, dog i en anden rækkefølge end vi normalt ville vælge ved udregning i hånden.


\subsubsection{Matricer \sphinxhyphen{} definition og regneoperationer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:matricer-definition-og-regneoperationer}}
Matricer defineres på samme måde, som vi har gjort det med vektorer, altså ved at benytte Matrix()\sphinxhyphen{}funktionen. Når vi laver en matrix, så skal vi dog give en liste af rækker, der hver især selv er lister. Formatet er det samme, som man bruger til at lave arrays i numpy. Hvis man eksempelvis blot vil lave en tabel med indgange fra 1 til 9, skal man angive det som:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_18_0}.png}

Det er naturligvis en forudsætning, at alle rækkerne har lige mange elementer.

Som for vektorer, kan vi benytte symboler i matricer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_20_0}.png}

Også addition og skalarmultiplikation fungerer som for vektorer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{B}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_22_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{42}\PYG{o}{*}\PYG{n}{B}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_23_0}.png}

Matricer kan også multipliceres med hinanden (se Messer afsnit 5.1) så længe de har passende dimensioner. Man kan opfatte indgangen på plads (i,j) i produktet AB som prikproduktet af den i’te række i A med den j’te søjle i B, og for at dette kan lade sig gøre, skal antallet af søjler i A være det samme som antallet af rækker i B. Vi kan også skrive betingelsen som at hvis A er en matrix af dimension \(m \times n\), skal B have dimension \(n \times p\)). I dette tilfælde kan vi gange dem sammen ved at benytte *:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{*} \PYG{n}{B}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_25_0}.png}


\subsubsection{Nogle indbyggede matricer: Identitets\sphinxhyphen{}, nul\sphinxhyphen{}, et\sphinxhyphen{} og diagonalmatricer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:nogle-indbyggede-matricer-identitets-nul-et-og-diagonalmatricer}}
Til at definere en række meget almindeligt forekommende matricer er der indbygget smutveje.

Disse matricer skal importeres fra sympy.matrices.

\sphinxstylestrong{Identitetsmatricer:} findes ved funktionen eye(dimension). Navnet skyldes at “eye” udtales omtrent som “I”, der ofte anvendes som symbol for identitetsmatricen, men allerede er reserveret til den imaginære enhed for komplekse tal. Da identitetsmatricen pr. definition er kvadratisk, angiver man blot dimensionen \(n\) og får en \(n\times n\) matrix med \(1\) i diagonalen og \(0\) alle andre steder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{matrices} \PYG{k+kn}{import} \PYG{n}{eye}

\PYG{n}{Id4} \PYG{o}{=} \PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Id4}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_27_0}.png}

\sphinxstylestrong{0\sphinxhyphen{} og 1\sphinxhyphen{}matricer:} Funktionerne zeros(dimension) og ones(dimension) giver en matrix af den ønskede størrelse fyldt med hhv. 0 eller 1\sphinxhyphen{}taller. Her kan dimension være to tal n, m eller et enkelt tal n, hvilket resulterer i en \(n \times n\) matrix:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{matrices} \PYG{k+kn}{import} \PYG{n}{zeros}\PYG{p}{,} \PYG{n}{ones}

\PYG{n}{nul\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{nul\PYGZus{}matrix}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_29_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fire\PYGZus{}matrix} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{fire\PYGZus{}matrix}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_30_0}.png}

\sphinxstylestrong{Diagonalmatricer:} laves med funktionen diag(liste). Denne funktion giver man som input blot en liste med de ønskede diagonalelementer. Alle andre indgange er \(0\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{matrices} \PYG{k+kn}{import} \PYG{n}{diag}

\PYG{n}{D} \PYG{o}{=} \PYG{n}{diag}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{D}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_32_0}.png}

Man kan også indsætte matricer langs diagonalen i større maricer, således at man får en blok\sphinxhyphen{}diagonal\sphinxhyphen{}matrix. Man kan f.eks. indsætte en matrix, der beskriver en rotation i planen, i en større matrix, der beskriver samme rotation i \((x,y)\)\sphinxhyphen{}planen indlejret i et tredimensionalt rum:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{theta}   \PYG{c+c1}{\PYGZsh{} Importer theta}

\PYG{c+c1}{\PYGZsh{} Definer matrix}
\PYG{n}{plan\PYGZus{}rot} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plan\PYGZus{}rot}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_34_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Lav diagonal med et 1\PYGZhy{}tal og så en matrice. diag fylder nu 0 ud alle andre steder.}
\PYG{n}{rum\PYGZus{}rot} \PYG{o}{=} \PYG{n}{diag}\PYG{p}{(}\PYG{n}{plan\PYGZus{}rot}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{rum\PYGZus{}rot}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_35_0}.png}

Det er desuden muligt at sætte matricer sammen og definere matricer hvor hver indgang er resulatet af en beregning eller logisk test. \sphinxhref{https://docs.sympy.org/latest/modules/matrices/matrices.html}{Disse metoder kan findes i dokumentationen her} med vil sjældent være nødvendige i LinALys\sphinxhyphen{}kurset.


\subsection{Matrix\sphinxhyphen{}reduktion}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:matrix-reduktion}}
Python/SymPy indeholder en række indbyggede metoder til at reducere matricer. Særligt brugbart i LinALys er funktionen, der bringer en matrix på reduceret række\sphinxhyphen{}echelonform. For en matrix \(A\) kan vi finde den ækvivalente matrix på reduceret række\sphinxhyphen{}echelonform ved .rref():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{rref}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_38_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_38_1}.png}

Resultatet er den reducerede række\sphinxhyphen{}echelonform og en liste over nummeret på de kolonner, der har en ledende indgang. Hvis man vil udelade denne liste, kan man i stedet skrive .rref(pivots = False).


\subsection{Ligningssystemer med een løsning}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:ligningssystemer-med-een-losning}}
Som det nok er gået op for de fleste, anviser lineær algebra en effektiv måde til at bestemme løsningerne til lineære ligningssystemer ved hjælpe af matrixregning. Vi kan f.eks. omskrive:

\textbackslash{}begin\{align*\}
x\_1 + 3 x\_3 \&= 20 \textbackslash{} 4x\_2 + 6 x\_3 \&= 74 \textbackslash{} 3 x\_1 + 6x\_2 + 11 x\_3 \&= 136
\textbackslash{}end\{align*\}

til:

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3\textbackslash{}0 \& 4 \& 6\textbackslash{}3 \& 6 \& 11\textbackslash{}end\{matrix\}\textbackslash{}right{]} \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}20\textbackslash{}74\textbackslash{}136\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

Når vi har et ligningssystem på denne form, og der findes en entydig løsning, kan vi uden videre beregne løsningen med SymPy. Vi benytter blot LUsolve\sphinxhyphen{}metoden på en matrix, og giver den højre side af vores ligningssystem som inputparameter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Definerer her matrix A og vektor b}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{74}\PYG{p}{,} \PYG{l+m+mi}{136}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Løsningen findes nu blot ved:}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{LUsolve}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sol}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_46_0}.png}

Skulle vi være mistroiske overfor moderne datamater, kan vi nu verificere at

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}5 \textbackslash{}11\textbackslash{}5\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

virkelig er en løsning ved at multiplicere matricen \(A\) med løsningsvektoren:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{*} \PYG{n}{sol}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_48_0}.png}

Vi kan lave tilsvarende operationer med symbolske variable. Lad \(A\) være matricen angivet ovenfor, men i stedet ønsker vi nu at finde en generel løsning til

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3\textbackslash{}0 \& 4 \& 6\textbackslash{}3 \& 6 \& 11\textbackslash{}end\{matrix\}\textbackslash{}right{]} \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}d\textbackslash{}e\textbackslash{}f\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}


\subsection{Omvendte/inverse matricer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:omvendte-inverse-matricer}}
Som beskrevet i Messer afsnit 5.2 kan matricer inverteres. Dette gøres meget simpelt for en matrix \(A\) med syntaksen A.inv():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_51_0}.png}

Såfremt den omvendte/inverse matrix for \(A\) eksisterer, kan vi derfor også løse det ovenstående ligningssystem som

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} =
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3\textbackslash{}0 \& 4 \& 6\textbackslash{}3 \& 6 \& 11\textbackslash{}end\{matrix\}\textbackslash{}right{]}\textasciicircum{}\{\sphinxhyphen{}1\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}d\textbackslash{}e\textbackslash{}f\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

hvilket i Python\sphinxhyphen{}syntax gøres ved

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{b}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_53_0}.png}


\subsection{Matrixrang}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:matrixrang}}
Bemærk at hverken man hverken kan finde løsninger med LUsolve eller ved at beregne den inverse matrix hvis  ikke ligningssystemet har netop én løsning (dvs. hvis ligningerne i ligningssystemet har indbygget en modstrid eller løsningen har en eller flere frie variable). I disse tilfælde vil begge metoder give fejlmeddelelser.

Årsagen hertil er at koefficientmatricen ikke har fuld rang. Rangen for en matrix \(A\) kan findes ved A.rank(), og angiver antallet af ledende et\sphinxhyphen{}taller i den matrix, der fremkommer ved at føre \(A\) på reduceret række\sphinxhyphen{}echelonform.

Af denne grund, og i overensstemmelse med Messer sætning 5.12, er det derfor ingen overraskelse at se at \(A\) fra overfor, der repræsenterer 3 lineært uafgængige ligninger med 3 ubekendte, har rang 3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{rank}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_55_0}.png}


\subsection{Ligningssystemer med flere løsninger: frie parametre}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1:ligningssystemer-med-flere-losninger-frie-parametre}}
Vi kommer dog ofte ud for ligningssystemer med flere ubekendte end der er lineært uafhængige ligninger, svarende til at løsningen kan parametriseres med et antal fri variable/parametre. Dette svarer til at rangen af den tilsvarende koefficientmatrix \(A\) er mindre end antallet af variable i ligningssystemet.
I sådanne tilfælde er A ikke invertibel og LU\sphinxhyphen{}solve vil derfor ikke virke.

Eksempel: Vi vil gerne finde den fuldstændige løsning til
\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3 \& 1\textbackslash{}0 \& 4 \& 6 \& 1\sphinxhyphen{}1 \& 4 \& 3 \& 0\textbackslash{}end\{matrix\}\textbackslash{}right{]} \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}0\textbackslash{}0\textbackslash{}0\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

En mulighed er at føre \(A\) på reduceret række\sphinxhyphen{}echelonform:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{rref}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_57_0}.png}

Vi sætter \(x_3 = r\) og \(x_4 = s\) da der ikke er ledende indgange i 3. og 4. kolonne. Herefter opskriver vi løsningen som
\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}x\_4\textbackslash{}end\{matrix\}\textbackslash{}right{]} =
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}\sphinxhyphen{}3\sphinxhyphen{}\textbackslash{}frac32\textbackslash{}1\textbackslash{}0\textbackslash{}end\{matrix\}\textbackslash{}right{]}\textbackslash{}cdot r +
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}\sphinxhyphen{}1\sphinxhyphen{}\textbackslash{}frac14\textbackslash{}0\textbackslash{}1\textbackslash{}end\{matrix\}\textbackslash{}right{]}\textbackslash{}cdot s, \textbackslash{}hspace\{1cm\}r,s\textbackslash{}in \{\textbackslash{}rm I!R\}
\textbackslash{}end\{equation*\}

Men vi kan også benytte metoden .gauss\_jordan\_solve() som efterligner denne metode, blot med en lidt anden typografi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{gauss\PYGZus{}jordan\PYGZus{}solve}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_59_0}.png}


\section{Matrix reduktion, ligningsløsning og inverse matricer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5:matrix-reduktion-ligningslosning-og-inverse-matricer}}\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5::doc}}

\subsection{Matrix\sphinxhyphen{}reduktion}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5:matrix-reduktion}}
Python/SymPy indeholder en række indbyggede metoder til at reducere matricer. Særligt brugbart i LinALys er funktionen, der bringer en matrix på reduceret række\sphinxhyphen{}echelonform. For en matrix \(A\) kan vi finde den ækvivalente matrix på reduceret række\sphinxhyphen{}echelonform ved .rref():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{rref}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_2_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_2_1}.png}

Resultatet er den reducerede række\sphinxhyphen{}echelonform og en liste over nummeret på de kolonner, der har en ledende indgang. Hvis man vil udelade denne liste, kan man i stedet skrive .rref(pivots = False).


\subsection{Ligningssystemer med een løsning}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5:ligningssystemer-med-een-losning}}
Som det nok er gået op for de fleste, anviser lineær algebra en effektiv måde til at bestemme løsningerne til lineære ligningssystemer ved hjælpe af matrixregning. Vi kan f.eks. omskrive:

\textbackslash{}begin\{align*\}
x\_1 + 3 x\_3 \&= 20 \textbackslash{} 4x\_2 + 6 x\_3 \&= 74 \textbackslash{} 3 x\_1 + 6x\_2 + 11 x\_3 \&= 136
\textbackslash{}end\{align*\}

til:

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3\textbackslash{}0 \& 4 \& 6\textbackslash{}3 \& 6 \& 11\textbackslash{}end\{matrix\}\textbackslash{}right{]} \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}20\textbackslash{}74\textbackslash{}136\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

Når vi har et ligningssystem på denne form, og der findes en entydig løsning, kan vi uden videre beregne løsningen med SymPy. Vi benytter blot LUsolve\sphinxhyphen{}metoden på en matrix, og giver den højre side af vores ligningssystem som inputparameter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Definerer her matrix A og vektor b}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{74}\PYG{p}{,} \PYG{l+m+mi}{136}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Løsningen findes nu blot ved:}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{LUsolve}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sol}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_10_0}.png}

Skulle vi være mistroiske overfor moderne datamater, kan vi nu verificere at

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}5 \textbackslash{}11\textbackslash{}5\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

virkelig er en løsning ved at multiplicere matricen \(A\) med løsningsvektoren:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{*} \PYG{n}{sol}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_12_0}.png}

Vi kan lave tilsvarende operationer med symbolske variable. Lad \(A\) være matricen angivet ovenfor, men i stedet ønsker vi nu at finde en generel løsning til

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3\textbackslash{}0 \& 4 \& 6\textbackslash{}3 \& 6 \& 11\textbackslash{}end\{matrix\}\textbackslash{}right{]} \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}d\textbackslash{}e\textbackslash{}f\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}


\subsection{Omvendte/inverse matricer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5:omvendte-inverse-matricer}}
Som beskrevet i Messer afsnit 5.2 kan matricer inverteres. Dette gøres meget simpelt for en matrix \(A\) med syntaksen A.inv():

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_15_0}.png}

Såfremt den omvendte/inverse matrix for \(A\) eksisterer, kan vi derfor også løse det ovenstående ligningssystem som

\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} =
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3\textbackslash{}0 \& 4 \& 6\textbackslash{}3 \& 6 \& 11\textbackslash{}end\{matrix\}\textbackslash{}right{]}\textasciicircum{}\{\sphinxhyphen{}1\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}d\textbackslash{}e\textbackslash{}f\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

hvilket i Python\sphinxhyphen{}syntax gøres ved

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{b}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_17_0}.png}


\subsection{Matrixrang}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5:matrixrang}}
Bemærk at hverken man hverken kan finde løsninger med LUsolve eller ved at beregne den inverse matrix hvis  ikke ligningssystemet har netop én løsning (dvs. hvis ligningerne i ligningssystemet har indbygget en modstrid eller løsningen har en eller flere frie variable). I disse tilfælde vil begge metoder give fejlmeddelelser.

Årsagen hertil er at koefficientmatricen ikke har fuld rang. Rangen for en matrix \(A\) kan findes ved A.rank(), og angiver antallet af ledende et\sphinxhyphen{}taller i den matrix, der fremkommer ved at føre \(A\) på reduceret række\sphinxhyphen{}echelonform.

Af denne grund, og i overensstemmelse med Messer sætning 5.12, er det derfor ingen overraskelse at se at \(A\) fra overfor, der repræsenterer 3 lineært uafgængige ligninger med 3 ubekendte, har rang 3:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{rank}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_19_0}.png}


\subsection{Ligningssystemer med flere løsninger: frie parametre}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg1_5:ligningssystemer-med-flere-losninger-frie-parametre}}
Vi kommer dog ofte ud for ligningssystemer med flere ubekendte end der er lineært uafhængige ligninger, svarende til at løsningen kan parametriseres med et antal fri variable/parametre. Dette svarer til at rangen af den tilsvarende koefficientmatrix \(A\) er mindre end antallet af variable i ligningssystemet.
I sådanne tilfælde er A ikke invertibel og LU\sphinxhyphen{}solve vil derfor ikke virke.

Eksempel: Vi vil gerne finde den fuldstændige løsning til
\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}1 \& 0 \& 3 \& 1\textbackslash{}0 \& 4 \& 6 \& 1\sphinxhyphen{}1 \& 4 \& 3 \& 0\textbackslash{}end\{matrix\}\textbackslash{}right{]} \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}end\{matrix\}\textbackslash{}right{]} = \textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}0\textbackslash{}0\textbackslash{}0\textbackslash{}end\{matrix\}\textbackslash{}right{]}
\textbackslash{}end\{equation*\}

En mulighed er at føre \(A\) på reduceret række\sphinxhyphen{}echelonform:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{rref}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_21_0}.png}

Vi sætter \(x_3 = r\) og \(x_4 = s\) da der ikke er ledende indgange i 3. og 4. kolonne. Herefter opskriver vi løsningen som
\textbackslash{}begin\{equation*\}
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}x\_\{1\}\textbackslash{}x\_\{2\}\textbackslash{}x\_\{3\}\textbackslash{}x\_4\textbackslash{}end\{matrix\}\textbackslash{}right{]} =
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}\sphinxhyphen{}3\sphinxhyphen{}\textbackslash{}frac32\textbackslash{}1\textbackslash{}0\textbackslash{}end\{matrix\}\textbackslash{}right{]}\textbackslash{}cdot r +
\textbackslash{}displaystyle \textbackslash{}left{[}\textbackslash{}begin\{matrix\}\sphinxhyphen{}1\sphinxhyphen{}\textbackslash{}frac14\textbackslash{}0\textbackslash{}1\textbackslash{}end\{matrix\}\textbackslash{}right{]}\textbackslash{}cdot s, \textbackslash{}hspace\{1cm\}r,s\textbackslash{}in \{\textbackslash{}rm I!R\}
\textbackslash{}end\{equation*\}

Men vi kan også benytte metoden .gauss\_jordan\_solve() som efterligner denne metode, blot med en lidt anden typografi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{gauss\PYGZus{}jordan\PYGZus{}solve}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg1_5_23_0}.png}

\sphinxstylestrong{Foreslået ændringer}Der er ikke meget, som skal ændres i denne Notebook. Vi skal sandsynligvis tilpasse den til at overholde de nye konventioner, som vi sætter for os selv. Dvs tænke over import og lign.. Ellers burde den være good to go


\section{Flere metoder i Linær Algebra}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:flere-metoder-i-linaer-algebra}}\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2::doc}}
Målet for denne notebook er at give en oversigt over de funktioner, som man kan få brug for, når man benytter SymPy som redskab i lineær algebra. Vi arbejder videre hvor den første notebook om lineær algebra slap, så fra starten antager vi at læseren kan lave matrix\sphinxhyphen{} og vektormanipulationer.

Langt de fleste funktioner i denne notebook virker på samme måde som matrixinversion, som for en matrix \(A\) findes ved A.inv().

Først importerer vi de rette pakker:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}              \PYG{c+c1}{\PYGZsh{} Importer sympy }
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}              \PYG{c+c1}{\PYGZsh{} Flot print}

\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{oo}\PYG{p}{,} \PYG{n}{I}     \PYG{c+c1}{\PYGZsh{} Symboler, som det er smart at have klar}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{Matrix}        \PYG{c+c1}{\PYGZsh{} Vi kommer til at lave mange matricer i denne notebook}

\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}
\end{sphinxVerbatim}


\subsection{Transponering, adjungering og konjugering}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:transponering-adjungering-og-konjugering}}
Hvis vi har givet en matrix, kan vi nemt beregne den transponerede matrix med at ombytte rækker og kolonner:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_4_0}.png}

Den transponerede beregnes med .T

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{T}    \PYG{c+c1}{\PYGZsh{} Bemærk, at der ikke skal parenteser bag T}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_6_0}.png}

Messer arbejder ikke med komplekse tal som indgange i matricer, men hvis man gør (og det er der mange gode grunde til, f.eks. i kvantemekanik), vil man også møde den såkaldte konjugerede matrix A.conjugate() (der fremkommer ved kompleks konjugering af indgangene af \(A\)) og den såkaldte adjungerede (matricen der er \(A\)s transponerede konjugerede matrix) A.adjoint() eller nemmere A.H . Notationen med H kommer af at den adjungerede matrix også kaldes den hermitisk konjugerede.
Eksempelvis kan vi finde den konjugerede matrix her:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n}{I}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{I}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{I}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_8_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_8_1}.png}

hvor vi ser at alle imaginærdelene har skiftet fortegn.
Som eksempel på den adjungerede (altså komplekst konjugerede og transponerede) matrix får vi

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{H}     \PYG{c+c1}{\PYGZsh{} Som med .T indeholder syntaksen ikke ()}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_10_0}.png}


\subsection{Nulrum og søjlerum}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:nulrum-og-sojlerum}}
For en matrix \(M\) kan vi finde dennes nulrum og søjlerum ved at bruge hhv. M.nullspace() og M.columnspace().

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{nullspace}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_12_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_12_1}.png}

Hvilket giver en liste (her med eet element) af vektorer som er basis for matricens nulrum. Altså vektorer som opfylder ligningen \(M\boldsymbol{x} = \boldsymbol{0}\). Dette gælder derfor også for linearkombinationer af vektorerne i nulrummet.

Søjlerummet findes helt tilsvarende:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{columnspace}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_14_0}.png}

Herved får vi en liste af vektorer, som udspænder søjlerummet, og som består af de søjler fra \(M\), der indeholder ledende indgange når \(M\) er bragt på række\sphinxhyphen{}echelonform. Dette verificerer vi ved at betragte \(M\)s ækvivalente matrix på reduceret række\sphinxhyphen{}echelonform:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M}\PYG{o}{.}\PYG{n}{rref}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_16_0}.png}


\subsection{Gram\sphinxhyphen{}Schmidt\sphinxhyphen{}ortogonalisering}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:gram-schmidt-ortogonalisering}}
Er vi givet flere vektorer i rummet som ikke er lineært afhængigt af hinanden, kan vi danne et ortogonalt (og evt. ortonomalt, hvis vi normaliserer vektorerne) sæt af vektorer ved at bruge Gram\sphinxhyphen{}Schmidt\sphinxhyphen{}ortogonalisering.

Dette kan være en ret omgangsrig procedure, som man i LinALys kun vil blive bedt om at udføre i relativt simple tilfælde. Men selv i disse simple tilfælde er der masser af muligheder for at lave regnefejl, og det kan derfor være rart hurtigt at kunne checke beregningerne, især for når der er tale om mere end 2\sphinxhyphen{}3 vektorer. Til dette importerer man GramSchmidt fra sympy.matrices og benytter den på en liste \(L\) af vektorer: GramScmidt(L). Som udgangspunkt normaliserer SymPy ikke de ortogonaliserede vektorer, men hvis vi giver funktionen et ekstra argument GramSchmidt(L, True), fortages normaliseringen som en del af beregningen.

Som eksempel genregner vi her eksemplet fra side 162 i Messer med SymPy:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{matrices} \PYG{k+kn}{import} \PYG{n}{GramSchmidt}

\PYG{c+c1}{\PYGZsh{} Definer en liste med matrix indgange, som nu er vektorer}
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_19_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Vi benytter nu GramScmidt}
\PYG{n}{GramSchmidt}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_20_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Eller hvis vi vil inkluderer en normalisering gør vi følgende:}
\PYG{n}{GramSchmidt}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_21_0}.png}

hvilket kan ses at passe med Messers
\begin{equation*}
\begin{split}\left\{ \left(\frac{1}{3}, \frac{2}{3}, \frac{2}{3}\right), \left(\frac{-2}{\sqrt{45}}, \frac{5}{\sqrt{45}}, \frac{-4}{\sqrt{45}}\right),\left(\frac{-2}{\sqrt{5}}, 0, \frac{1}{\sqrt{5}}\right)\right\}\end{split}
\end{equation*}
ved anvendelse af kvadratrods\sphinxhyphen{} og brøkregneregler.


\subsection{Determinant}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:determinant}}
Determinanten beregnes ved at tilføje .det() til matricens navn:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_24_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_24_1}.png}

Vi kan også beregne determinanten for en symbolsk matrix:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d}

\PYG{n}{B} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{n}{d}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}

\PYG{n}{B}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_26_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_26_1}.png}

i overensstemmelse med, hvordan vi selv ville regne den.


\subsection{Sporet / Trace}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:sporet-trace}}
Sporet udregnes ved at tilføje .trace() til den ønskede matrix, hvilket giver summen af diagonalindgangene:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{trace}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_29_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_29_1}.png}


\subsection{Krydsprodukt, vektorprodukt / Cross product}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:krydsprodukt-vektorprodukt-cross-product}}
For to vektorer i tre dimensioner kan vi benytte beregne krydsproduktet mellem v og w med v.cross(w) (i analogi med syntaksen for det indre produkt):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n}{cross}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_31_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_31_1}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_31_2}.png}


\subsection{Egenværdier og \sphinxhyphen{}vektorer}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:egenvaerdier-og-vektorer}}
For en matrix findes egenværdier og \sphinxhyphen{}vektorer med A.eigenvals() og A.eigenvects().

A.eigenvals() giver os blot alle egenværdierne til en bestemt matrice i sorteret rækkefølge:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_33_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{eigenvals}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_34_0}.png}

Dette giver os nu en liste over egenværdierne (altså, 1, 2 og 11) og deres algebraiske multiplicitet, altså hvor mange gange den pågældende egenværdi er rod i det karakteristiske polynomium (her har alle egenværdierne algebraiske multiplicitet 1). For at illustrere hvordan resultaterne vises, “beregner” vi her egenværdierne for et trivielt eksempel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{matrices} \PYG{k+kn}{import} \PYG{n}{eye}
\PYG{n}{B} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_36_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{eigenvals}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_37_0}.png}

Funktionen .eigenvects virker på samme måde og giver både egenværdier og \sphinxhyphen{}vektorerne:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{eigenvects}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_39_0}.png}

Her er resultatet altså givet som en liste med (egenværdi, multiplictet, egenvektorer). Vi kan igen prøve eksemplet med det trivielle eksempel for at vise, hvad der sker, når en egenværdi har flere tilhørende egenvektorer:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B}\PYG{o}{.}\PYG{n}{eigenvects}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_41_0}.png}

I matematikkurser har matricerne gerne pæne (ofte heltallige) egenværdier, mens man i praksis sjældent oplever matricer med så velopdragne egenværdier. Dertil kommer, at store matricer kan gøre det meget hårdt for computeren at regne det hele symbolsk. Derfor vil man (når man eksempelvis beregner egenværdier i kvantemekanik) i stedet bruge NumPy, da der her er nogle ret hurtige implementeringer til at give gode numeriske løsninger. Heldigvis ligner metoderne meget hinanden, og hvis man skulle komme ud for at skulle løse et problem, der er for krævende med sumbolske beregninger, kan man finde NumPys LinAlg værktøjer \sphinxhref{https://numpy.org/doc/stable/reference/routines.linalg.html}{i den relevante dokumentation}.


\subsection{Diagonalisering}
\label{\detokenize{notebooks/sympy/Notebook_LinAlg_2:diagonalisering}}
En afgørende pointe i kurset er at undersøge hvornår der kan findes en base hvor vores matrix \(A\) er på diagonalform, altså hvornår der findes en matrix \(P\), der opfylder: \(D = P^{-1}AP\), hvor \(D\) er en diagonalmatrix. For at finde denne kan vi benytte A.diagonalize(). Vi regner videre med matricen A defineret ovenfor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_44_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{n}{diagonalize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_45_0}.png}

Outputtet for denne funktion er matricerne \(P\) og \(D\). Vi genkender at matricen \(D\) netop indeholder egenværdierne langs diagonalen og at \(P\) består at (multipla af) egenvektorerne. Vi kan få de pågældende matricer ud så vi kan regne videre med dem på følgende måde:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{P}\PYG{p}{,} \PYG{n}{D}\PYG{p}{)} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{diagonalize}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,} \PYG{n}{D}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_47_0}.png}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_47_1}.png}

Og vi demonstrerer endelig at matricerne sammensættes som forventet. Først \(D = P^{-1}AP\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{P}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{A} \PYG{o}{*} \PYG{n}{P}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_49_0}.png}

Eller omvendt \(A = P D P^{-1}\)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{P} \PYG{o}{*} \PYG{n}{D} \PYG{o}{*} \PYG{n}{P}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_LinAlg_2_51_0}.png}

\sphinxstylestrong{Foreslået ændringer:}Her skal der ryddes lidt op, og så skal vi ændre måden vi plotter komplekse tal på, til at benytte numpys mulighed for at have komplekse arrays.


\section{Komplekse tal i SymPy}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:komplekse-tal-i-sympy}}\label{\detokenize{notebooks/sympy/Notebook_kompleks::doc}}
I LinALys lærer du at regne med komplekse tal. SymPy kan være en hjælp f.eks. til at visualisere alle løsninger til komplekse ligninger, men er i kurset primært et værktøj som du kan bruge til at checke de beregninger, der indgår i pointopgaverne og den afsluttende eksamen. Især hvis du har erfaring med at du laver mange regnefejl i omfattende beregninger, kan det være godt at checke beregningerne trin for trin i SymPy.

Vi starter med at importere den imaginære enhed ved hjælp af from sympy import I, \(I\) er SymPys standardsyntaks for det imaginære tal \(i\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{I}\PYG{p}{,} \PYG{n}{pi}
\end{sphinxVerbatim}


\subsection{Almindelige regneoperationer med komplekse tal}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:almindelige-regneoperationer-med-komplekse-tal}}
Når vi benytter I, får vi automatisk et komplekst tal, og SymPy behandler det som sådan ganske automatisk. Vi kan altså skrive \(z = 3 + 4i\) som z = 3 + 4 * I:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_6_0}.png}

Eller vi kan lave et mere generelt udtryk, hvor vi istedet benytter symboler:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_8_0}.png}

Når vi først har defineret vores udtryk, så kan vi regne med dem på samme måde som med alle andre (reelle) tal. Regneoperationerne +, \sphinxhyphen{}, * og / fungerer som de skal.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{w} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z} \PYG{o}{+} \PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_10_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z} \PYG{o}{\PYGZhy{}} \PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_11_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z} \PYG{o}{*} \PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_12_0}.png}

Ved multiplikation og division er det nogle gange en god idé at bede SymPy om at reducere udtrykket. Især, hvis man gerne vil have det på en \(x + yi\) form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{z} \PYG{o}{*} \PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_14_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z} \PYG{o}{/} \PYG{n}{w}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{z} \PYG{o}{/} \PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_15_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_15_1}.png}

Man kan desuden beregne potenser af et kompleks tal på sædvandligvis ved at bruge **:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_17_0}.png}

I dette tilfælde er der ikke meget hjælp at hente i simplify:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_19_0}.png}

Vi kan til gengæld bede SymPy om at gange parentesen ud med sp.expand:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{expand}\PYG{p}{(}\PYG{n}{z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_21_0}.png}

SymPy ved hvordan den skal håndtere komplekse tal i mange sammenhænge, hvor fortolkningen er entydig. Man altså blot bruge komplekse tal i sp.exp(), sp.cos() eller lignende.


\subsection{Notationsformer og skift mellem disse}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:notationsformer-og-skift-mellem-disse}}

\subsubsection{Kartesiske koordinater, real og imaginærdel.}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:kartesiske-koordinater-real-og-imaginaerdel}}
Funktionerne \sphinxhref{http://sp.re}{sp.re}() og \sphinxhref{http://sp.im}{sp.im}() giver real\sphinxhyphen{} og imaginærdelen af et komplekst tal. Det er naturligvis trivielt hvis vi starter med et imaginært tal af formen \(x + iy\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{7} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{re}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{im}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_25_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_25_1}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_25_2}.png}

Men det er mere oplysende, hvis vores komplekse tal har en anden form, for eksempel \(4 e^{i \pi / 3}\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{w} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{I} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{re}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{im}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_27_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_27_1}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_27_2}.png}


\subsubsection{Modulus og argument}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:modulus-og-argument}}
Vi kan desuden nemt beregne modulus og argument. Modulus for et komplekst tal er det samme som tallets absolutte værdi (TL s. 126) og findes med sp.Abs(). Bemærk at man bruger et stort A for at adskille kommandoen fra Pythons abs\sphinxhyphen{}funktion. For symbolske udtryk vil SymPy dog automatisk bruge sp.Abs() selv hvis vi bruger et lille a. Så for de to tal defineret ovenfor får vi:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Abs}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_30_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_30_1}.png}

Argumentet findes ved sp.arg() :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{arg}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{arg}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_32_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_32_1}.png}

Hvorefter vi som nævnt tidligere kan bruge .evalf(), hvis vi vil have et bud på værdien af \(-\arctan (7/10)\) med fire decimaler

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{arg}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{o}{.}\PYG{n}{evalf}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_34_0}.png}


\subsubsection{Kompleks konjugering}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:kompleks-konjugering}}
Vi vil ret ofte benytte os af kompleks konjugering, hvor vi skifter fortegn på imaginærdelen (eller spejler i den reelle akse). Dette kan vi gøre ved brug af sp.conjugate(), som virker på imaginære tal uanset notationsform. Bemærk at funktionen hedder det samme som den tilsvarende funktion for matricer, som vi kender fra Lineær Algebra, men som har en anden syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Konjugering af komplekst tal}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Konjugering af matrix ... men da z kan opfattes som en 1 x 1 matrix, er resultatet det samme}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_37_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_37_1}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_37_2}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{display}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_38_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_38_1}.png}


\subsection{Rødder og ligninger}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:rodder-og-ligninger}}
En central egenskab ved de komplekse tal er, at et polynomium af n’te grad altid har netop n rødder (med multiplicitet). Vi skal ofte finde rødder i polynomier og løsninger til ligninger, og her indgår der ofte kvadratrødder og andre rødder af komplekse tal. Se TK 3.4.2 s. 141, hvor det fremgår at der altid er netop \(n\) n’te rødder. Når vi vil finde den n’te rod af et komplekst tal, benytter vi sp.root. Syntaksen er således, at \(\sqrt[n]{z}\) skrives som sp.root(z, n, hvilken\_rod), hvor hvilken\_rod er et tal mellem \(0\) til \(n-1\) (husk at Python tæller fra 0) og fortæller SymPy, hvilken af de \(n\) rødder, den skal udregne.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{I}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_41_0}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{root}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_42_0}.png}

Dette er utvivlsomt korrekt, men når man ønsker et mere anvendeligt svar, kan man f.eks. tvinge SymPy til at udregne real\sphinxhyphen{}delen og imaginærdelen som vi gjorde ovenfor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r1} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{root}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{re}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{im}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_44_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_44_1}.png}

Vi vil nu se på rødderne i et simplere tilfælde, nemlig \(\sqrt[4]{-4}\).

Hvis vi ønsker at finde alle rødderne på en gang og få dem præsenteret i en liste, kan vi enten skrive det op som en ligning:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{x}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_46_0}.png}

Eller vi kan beregne rødderne en efter en ved hjælp af en for\sphinxhyphen{}løkke:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{root}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
    \PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{re}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)} \PYG{o}{+} \PYG{n}{I} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{im}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_48_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_48_1}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_48_2}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_48_3}.png}

Vi kan finde rødder til polynomier ved hjælp af sp.solve(). Vi minder om at hvis vi kun giver sp.solve() et udtryk (og altså ikke en ligning, f.eks. dannet ved hjælp af sp.Eq), så finder funktionen løsninger til den ligning, der fremkommer når udtrykket sættes lig 0:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{z} 
\PYG{c+c1}{\PYGZsh{} Definer p som også har imaginære rødder}
\PYG{n}{p} \PYG{o}{=}  \PYG{n}{z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{n}{z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{z} \PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}

\PYG{c+c1}{\PYGZsh{} Løs med sp.solve ved hjælp af udtrykket for p, der automatisk sættes lig nul}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} ... eller med en mindre elegant syntaks, hvor ligningen eksplicit er angivet til z3 \PYGZhy{} z\PYGZca{}2 + 4z = 4}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Eq}\PYG{p}{(}\PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{z}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_50_0}.png}

\noindent\sphinxincludegraphics{{Notebook_kompleks_50_1}.png}


\subsection{Visualisering i det komplekse plan}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:visualisering-i-det-komplekse-plan}}
Der er ikke et decideret tegneværktøj til komplekse tal i SymPy. Vi kan dog nå langt ved at lave udregningerne i SymPy og så tegne real\sphinxhyphen{} og imaginærdelene af tallet ved hjælp af \sphinxstyleemphasis{Matplotlib}.

Som eksempel vil vi prøve at visualisere hvad der sker, når vi tager et komplekst tal opløftet til en stigende potens.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Vi tager et eksempel med (1 + i/2)\PYGZca{}n for n = 0, ..., 11}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{I}\PYG{o}{/}\PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Tom liste}
\PYG{n}{zs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Vi kører nu igennem tolv gange (altså fra 0 til 11) og tilføjer potensen til en liste}
    \PYG{n}{zs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{expand}\PYG{p}{(}\PYG{n}{z} \PYG{o}{*}\PYG{o}{*} \PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
    
\PYG{n}{display}\PYG{p}{(}\PYG{n}{zs}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_54_0}.png}

Vi viser her to mulige måder at visualisere disse tal på. Den første bruger SymPy, mens vi i den anden bruger NumPy til at lave en lidt nemmere numerisk løsning


\subsubsection{Visualisering i SymPy}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:visualisering-i-sympy}}
Først danner vi realdelene \(x\) og imaginærdelene \(y\), så tegner vi, og til sidst tilføjer vi linjer svarende til de reelle og imaginære akser.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{xs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{ys} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{tal} \PYG{o+ow}{in} \PYG{n}{zs}\PYG{p}{:}
    \PYG{n}{xs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{re}\PYG{p}{(}\PYG{n}{tal}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ys}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{im}\PYG{p}{(}\PYG{n}{tal}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xs}\PYG{p}{,} \PYG{n}{ys}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bx}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_57_0}.png}

Vi ser at værdierne starter i \(z^0 = 1\) og spiralerer udaf idet \(|z|>1\) og modulus af \(z^n\) derfor vokser for stigende n. Argumentet vokser med en fast værdi hver gang \(n\) vokser med 1.


\subsubsection{Visualisering i NumPy}
\label{\detokenize{notebooks/sympy/Notebook_kompleks:visualisering-i-numpy}}
Benytter vi i stedet NumPy, kan vi komme lidt lettere om ved det, og da SymPy alligevel konverterer til numeriske værdier inden graftegning, taber vi ikke det store.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Vi laver et numpy array, hvor vi specificerer datatypen til et numerisk\PYGZhy{}komplekst tal}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{zs}\PYG{p}{,} \PYG{n}{dtype} \PYG{o}{=} \PYG{n+nb}{complex}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} Så kan vi plotte det med at tage de reelle og imaginære værdier ud af arrayet direkt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{zs}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{kx}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} ... og linjer, der kan gøre det ud for akser}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_59_0}.png}

Vi kan også bruge metoden til at vise rødderne i et polynomium.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy}\PYG{n+nn}{.}\PYG{n+nn}{abc} \PYG{k+kn}{import} \PYG{n}{z}

\PYG{n}{zs} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{zs}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_61_0}.png}

Her tegner vi ved hjælp af funktionen scatter, der giver mange grafiske muligheder for grafer bestående af enkelte “prikker”, altså ikke\sphinxhyphen{}forbundne talpar.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{zs}\PYG{p}{,} \PYG{n}{dtype} \PYG{o}{=} \PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{zs}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,} \PYG{n}{marker} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} ... og linjer, der kan gøre det ud for akser. Længden er valgt således at inddelingerne på \PYGZdq{}akserne\PYGZdq{} er omtrent det samme.}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.7}\PYG{p}{,} \PYG{l+m+mf}{2.7}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{Notebook_kompleks_63_0}.png}







\renewcommand{\indexname}{Index}
\printindex
\end{document}